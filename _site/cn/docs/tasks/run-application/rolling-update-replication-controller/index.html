<p>﻿—
approvers:</p>
<ul id="markdown-toc">
  <li><a href="#概述" id="markdown-toc-概述">概述</a></li>
  <li><a href="#通过配置文件更新" id="markdown-toc-通过配置文件更新">通过配置文件更新</a>    <ul>
      <li><a href="#示例" id="markdown-toc-示例">示例</a></li>
    </ul>
  </li>
  <li><a href="#更新容器镜像" id="markdown-toc-更新容器镜像">更新容器镜像</a>    <ul>
      <li><a href="#示例-1" id="markdown-toc-示例-1">示例</a></li>
    </ul>
  </li>
  <li><a href="#必选和可选字段" id="markdown-toc-必选和可选字段">必选和可选字段</a></li>
  <li><a href="#实践" id="markdown-toc-实践">实践</a></li>
  <li><a href="#故障分析" id="markdown-toc-故障分析">故障分析</a></li>
</ul>

<h2 id="概述">概述</h2>

<p><strong>注</strong>: 创建副本应用的首选方法是使用<a href="/docs/api-reference/v1.8/#deployment-v1beta1-apps">Deployment</a>，Deployment使用<a href="/docs/api-reference/v1.8/#replicaset-v1beta1-extensions">ReplicaSet</a>来进行副本控制。
更多信息, 查看<a href="/docs/tasks/run-application/run-stateless-application-deployment/">使用Deployment运行一个无状态应用</a>。</p>

<p>为了在更新服务的同时不中断业务， <code class="highlighter-rouge">kubectl</code> 支持<a href="/docs/user-guide/kubectl/v1.6/#rolling-update">‘滚动更新’</a>，它一次更新一个pod，而不是同时停止整个服务。 有关更多信息，请参阅 <a href="https://git.k8s.io/community/contributors/design-proposals/cli/simple-rolling-update.md">滚动更新设计文档</a> 和 <a href="/docs/tasks/run-application/rolling-update-replication-controller/">滚动更新示例</a>。</p>

<p>请注意， <code class="highlighter-rouge">kubectl rolling-update</code> 仅支持Replication Controllers。 但是，如果使用Replication Controllers部署应用，请考虑将其切换到<a href="/docs/concepts/workloads/controllers/deployment/">Deployments</a>. Deployment是一种被推荐使用的更高级别的控制器，它可以对应用进行声明性的自动滚动更新。 如果您仍然希望保留您的Replication Controllers并使用 <code class="highlighter-rouge">kubectl rolling-update</code>进行滚动更新， 请继续往下阅读：</p>

<p>滚动更新可以对replication controller所管理的Pod的配置进行变更，变更可以通过一个新的配置文件来进行，或者，如果只更新镜像，则可以直接指定新的容器镜像。</p>

<p>滚动更新的工作流程：</p>

<ol>
  <li>通过新的配置创建一个replication controller</li>
  <li>在新的控制器上增加副本数，在旧的上面减少副本数，直到副本数达到期望值</li>
  <li>删除之前的replication controller</li>
</ol>

<p>使用<code class="highlighter-rouge">kubectl rolling-update</code>命令来进行滚动更新：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ kubectl rolling-update NAME \
    ([NEW_NAME] --image=IMAGE | -f FILE)
</code></pre></div></div>

<h2 id="通过配置文件更新">通过配置文件更新</h2>

<p>通过配置文件来进行滚动更新，需要在<code class="highlighter-rouge">kubectl rolling-update</code>命令后面带上新的配置文件：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ kubectl rolling-update NAME -f FILE
</code></pre></div></div>

<p>这个配置文件必须满足以下条件：</p>

<ul>
  <li>
    <p>指定不同的<code class="highlighter-rouge">metadata.name</code>值</p>
  </li>
  <li>
    <p>至少要修改<code class="highlighter-rouge">spec.selector</code>中的一个标签值</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">metadata.namespace</code>字段必须相同</p>
  </li>
</ul>

<p>Replication Controllers的配置文件详细介绍见<a href="/docs/tutorials/stateless-application/run-stateless-ap-replication-controller/">创建Replication Controllers</a>.</p>

<h3 id="示例">示例</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 通过新的配置文件frontend-v2.json来更新frontend-v1的pods
$ kubectl rolling-update frontend-v1 -f frontend-v2.json

// 将frontend-v2.json数据传到标准输入来更新frontend-v1的pods
$ cat frontend-v2.json | kubectl rolling-update frontend-v1 -f -
</code></pre></div></div>

<h2 id="更新容器镜像">更新容器镜像</h2>

<p>仅更新容器镜像的话，可通过如下命令，该命令可以指定一个新的控制器名称（可选），通过<code class="highlighter-rouge">--image</code>参数来指定新的镜像名称和标签。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ kubectl rolling-update NAME [NEW_NAME] --image=IMAGE:TAG
</code></pre></div></div>

<p><code class="highlighter-rouge">--image</code>参数仅支持单容器pod，多容器pod使用<code class="highlighter-rouge">--image</code>参数会返回错误。</p>

<p>如果没有指定 <code class="highlighter-rouge">NEW_NAME</code> ，新的replication controller创建后会使用一个临时名称，当更新完成，旧的controller被删除后，新的controller名称会被更新成旧的controller名称。</p>

<p>如果<code class="highlighter-rouge">IMAGE:TAG</code> 和当前值相同，更新就会失败。 因此，我们建议使用版本号来作为标签，而不是使用 <code class="highlighter-rouge">:latest</code>。从一个 <code class="highlighter-rouge">image:latest</code>镜像升级到一个新的 <code class="highlighter-rouge">image:latest</code> 镜像将会失败，即使这两个镜像不是相同的。
所以，我们不建议使用 <code class="highlighter-rouge">:latest</code> 来作为标签，详细信息见<a href="/docs/concepts/configuration/overview/#container-images">最佳配置实践</a> 。</p>

<h3 id="示例-1">示例</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 更新frontend-v1的pod到frontend-v2
$ kubectl rolling-update frontend-v1 frontend-v2 --image=image:v2

// 更新frontend的pods，不更改replication controller的名称
$ kubectl rolling-update frontend --image=image:v2
</code></pre></div></div>

<h2 id="必选和可选字段">必选和可选字段</h2>

<p>必选字段：</p>

<ul>
  <li><code class="highlighter-rouge">NAME</code>: 需要进行滚动更新的replication controller名称</li>
</ul>

<p>下面两个字段选其一：</p>

<ul>
  <li><code class="highlighter-rouge">-f FILE</code>: 新的replication controller的配置文件，JSON或者YAML格式均可。配置文件必须指定一个新的顶层<code class="highlighter-rouge">id</code>值，且至少包含一个现有<code class="highlighter-rouge">spec.selector</code>中的键值对。
详细信息见<a href="/docs/tutorials/stateless-application/run-stateless-ap-replication-controller/#replication-controller-configuration-file">通过Replication Controller运行无状态应用</a>。
<br />
<br />
  或者：
<br />
<br /></li>
  <li><code class="highlighter-rouge">--image IMAGE:TAG</code>: 更新后的镜像的名称和标签。必须和当前的image:tag不同。</li>
</ul>

<p>可选字段包括：</p>

<ul>
  <li><code class="highlighter-rouge">NEW_NAME</code>: 只和 <code class="highlighter-rouge">--image</code> 一起使用，不和 <code class="highlighter-rouge">-f FILE</code> 一起使用。标识新的replication controller的名称。</li>
  <li><code class="highlighter-rouge">--poll-interval DURATION</code>: 在更新后轮询控制器状态的间隔时间。有效单位有 <code class="highlighter-rouge">ns</code> （纳秒），<code class="highlighter-rouge">us</code> 或 <code class="highlighter-rouge">µs</code>（微秒），<code class="highlighter-rouge">ms</code>（毫秒），<code class="highlighter-rouge">s</code>（秒），<code class="highlighter-rouge">m</code>（分钟）或 <code class="highlighter-rouge">h</code>（小时）。 单位可以自由组合（例如 <code class="highlighter-rouge">1m30s</code>）。 默认值为 <code class="highlighter-rouge">3s</code>。</li>
  <li><code class="highlighter-rouge">--timeout DURATION</code>: 退出更新之前，等待控制器更新一个pod的最大时间。默认是<code class="highlighter-rouge">5m0s</code>。有效单位如<code class="highlighter-rouge">--poll-interval</code>所述。</li>
  <li><code class="highlighter-rouge">--update-period DURATION</code>: 更新两个pod之间等待的时间，默认值是<code class="highlighter-rouge">1m0s</code>。有效单位如<code class="highlighter-rouge">--poll-interval</code>所述。</li>
</ul>

<p>有关<code class="highlighter-rouge">kubectl rolling-update</code>命令的更多信息见<a href="/docs/user-guide/kubectl/v1.6/#rolling-update"><code class="highlighter-rouge">kubectl</code>参考</a>.</p>

<h2 id="实践">实践</h2>

<p>现在你运行了一个1.7.9版本的nginx应用：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">ReplicationController</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">my-nginx</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">replicas</span><span class="pi">:</span> <span class="s">5</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">nginx</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">containers</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">nginx</span>
        <span class="na">image</span><span class="pi">:</span> <span class="s">nginx:1.7.9</span>
        <span class="na">ports</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="s">80</span>
</code></pre></div></div>

<p>要更新到1.9.1版本，你可以使用<a href="https://git.k8s.io/community/contributors/design-proposals/cli/simple-rolling-update.md"><code class="highlighter-rouge">kubectl rolling-update --image</code></a>来指定一个新的镜像：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl rolling-update my-nginx <span class="nt">--image</span><span class="o">=</span>nginx:1.9.1
Created my-nginx-ccba8fbd8cc8160970f63f9a2696fc46
</code></pre></div></div>

<p>在终端上打开另一个窗口 ，你可以看到<code class="highlighter-rouge">kubectl</code> 给每个pod都增加了一个值为配置文件哈希值的 <code class="highlighter-rouge">deployment</code> 标签，用来区分新旧pod：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl get pods <span class="nt">-l</span> <span class="nv">app</span><span class="o">=</span>nginx <span class="nt">-L</span> deployment
NAME                                              READY     STATUS    RESTARTS   AGE       DEPLOYMENT
my-nginx-ccba8fbd8cc8160970f63f9a2696fc46-k156z   1/1       Running   0          1m        ccba8fbd8cc8160970f63f9a2696fc46
my-nginx-ccba8fbd8cc8160970f63f9a2696fc46-v95yh   1/1       Running   0          35s       ccba8fbd8cc8160970f63f9a2696fc46
my-nginx-divi2                                    1/1       Running   0          2h        2d1d7a8f682934a254002b56404b813e
my-nginx-o0ef1                                    1/1       Running   0          2h        2d1d7a8f682934a254002b56404b813e
my-nginx-q6all                                    1/1       Running   0          8m        2d1d7a8f682934a254002b56404b813e
</code></pre></div></div>

<p>使用<code class="highlighter-rouge">kubectl rolling-update</code>可以实时看到更新的进度：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Scaling up my-nginx-ccba8fbd8cc8160970f63f9a2696fc46 from 0 to 3, scaling down my-nginx from 3 to 0 (keep 3 pods available, don't exceed 4 pods)
Scaling my-nginx-ccba8fbd8cc8160970f63f9a2696fc46 up to 1
Scaling my-nginx down to 2
Scaling my-nginx-ccba8fbd8cc8160970f63f9a2696fc46 up to 2
Scaling my-nginx down to 1
Scaling my-nginx-ccba8fbd8cc8160970f63f9a2696fc46 up to 3
Scaling my-nginx down to 0
Update succeeded. Deleting old controller: my-nginx
Renaming my-nginx-ccba8fbd8cc8160970f63f9a2696fc46 to my-nginx
replicationcontroller "my-nginx" rolling updated
</code></pre></div></div>

<p>如果遇到问题，你可以中途停止滚动更新，并且使用 <code class="highlighter-rouge">--rollback</code> 来回滚到以前的版本:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl rolling-update my-nginx <span class="nt">--rollback</span>
Setting <span class="s2">"my-nginx"</span> replicas to 1
Continuing update with existing controller my-nginx.
Scaling up nginx from 1 to 1, scaling down my-nginx-ccba8fbd8cc8160970f63f9a2696fc46 from 1 to 0 <span class="o">(</span>keep 1 pods available, don<span class="s1">'t exceed 2 pods)
Scaling my-nginx-ccba8fbd8cc8160970f63f9a2696fc46 down to 0
Update succeeded. Deleting my-nginx-ccba8fbd8cc8160970f63f9a2696fc46
replicationcontroller "my-nginx" rolling updated
</span></code></pre></div></div>

<p>这个例子说明容器的不变性是个巨大的优点。</p>

<p>如果你不仅仅是需要更新镜像，(例如，更新命令参数，环境变量等)，你可以创建一个新的replication controller配置文件，包含一个新的名称和不同的标签值，例如：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">ReplicationController</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">my-nginx-v4</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">replicas</span><span class="pi">:</span> <span class="s">5</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">app</span><span class="pi">:</span> <span class="s">nginx</span>
    <span class="na">deployment</span><span class="pi">:</span> <span class="s">v4</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">nginx</span>
        <span class="na">deployment</span><span class="pi">:</span> <span class="s">v4</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">containers</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">nginx</span>
        <span class="na">image</span><span class="pi">:</span> <span class="s">nginx:1.9.2</span>
        <span class="na">args</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">nginx"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">-T"</span><span class="pi">]</span>
        <span class="na">ports</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="s">80</span>
</code></pre></div></div>

<p>然后使用它来进行更新：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl rolling-update my-nginx <span class="nt">-f</span> ./nginx-rc.yaml
Created my-nginx-v4
Scaling up my-nginx-v4 from 0 to 5, scaling down my-nginx from 4 to 0 <span class="o">(</span>keep 4 pods available, don<span class="s1">'t exceed 5 pods)
Scaling my-nginx-v4 up to 1
Scaling my-nginx down to 3
Scaling my-nginx-v4 up to 2
Scaling my-nginx down to 2
Scaling my-nginx-v4 up to 3
Scaling my-nginx down to 1
Scaling my-nginx-v4 up to 4
Scaling my-nginx down to 0
Scaling my-nginx-v4 up to 5
Update succeeded. Deleting old controller: my-nginx
replicationcontroller "my-nginx-v4" rolling updated
</span></code></pre></div></div>

<h2 id="故障分析">故障分析</h2>

<p>如果更新过程中，达到超时时长<code class="highlighter-rouge">timeout</code>后还没更新完成，则更新会失败。这时，一些pod会属于新的replication controller，一些会属于旧的。</p>

<p>如果更新失败，可以尝试使用同样的命令来继续更新过程。</p>

<p>在尝试更新之前如果需要回滚到之前的状态，可在之前的命令后面添加<code class="highlighter-rouge">--rollback=true</code>参数，这将回退所有的更改。</p>
