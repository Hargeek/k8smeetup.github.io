
<p>默认情况下，Pod 运行没有限制 CPU 使用量和内存使用量。
这意味着当前系统中的任何 Pod 能够使用该 Pod 运行节点的所有 CPU 和内存资源。</p>

<p>这个例子演示了如何限制 Kubernetes <a href="/docs/tasks/administer-cluster/namespaces-walkthrough/">Namespace</a>，以此来控制每个 Pod 的最小/最大资源限额。
另外，这个例子演示了当终端用户没有为 Pod 设置资源限额时，如何使用默认的资源限额。</p>

<ul id="markdown-toc">
  <li><a href="#before-you-begin" id="markdown-toc-before-you-begin">Before you begin</a></li>
  <li><a href="#创建-namespace" id="markdown-toc-创建-namespace">创建 Namespace</a></li>
  <li><a href="#对-namespace-应用限制" id="markdown-toc-对-namespace-应用限制">对 Namespace 应用限制</a></li>
  <li><a href="#创建时强制设置限制" id="markdown-toc-创建时强制设置限制">创建时强制设置限制</a></li>
  <li><a href="#清理" id="markdown-toc-清理">清理</a></li>
  <li><a href="#设置资限额制的动机" id="markdown-toc-设置资限额制的动机">设置资限额制的动机</a></li>
  <li><a href="#总结" id="markdown-toc-总结">总结</a></li>
  <li><a href="#whats-next" id="markdown-toc-whats-next">What’s next</a></li>
</ul>

<h2 id="before-you-begin">Before you begin</h2>

<ul>
  <li>
    <p>You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
<a href="/docs/getting-started-guides/minikube">Minikube</a>,
or you can use one of these Kubernetes playgrounds:</p>
  </li>
  <li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
  <li><a href="http://labs.play-with-k8s.com/">Play with Kubernetes</a></li>
</ul>

<p>To check the version, enter <code class="highlighter-rouge">kubectl version</code>.</p>

<h2 id="创建-namespace">创建 Namespace</h2>

<p>这个例子将使用一个自定义的 Namespace 来演示相关的概念。</p>

<p>让我们创建一个名称为 limit-example 的 Namespace：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl create namespace limit-example
namespace <span class="s2">"limit-example"</span> created
</code></pre></div></div>

<p>可以看到 <code class="highlighter-rouge">kubectl</code> 命令将打印出被创建或修改的资源的类型和名称，也会在后面的命令中使用到：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl get namespaces
NAME            STATUS    AGE
default         Active    51s
limit-example   Active    45s
</code></pre></div></div>

<h2 id="对-namespace-应用限制">对 Namespace 应用限制</h2>

<p>在我们的 Namespace 中创建一个简单的限制：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl create <span class="nt">-f</span> https://k8s.io/docs/tasks/configure-pod-container/limits.yaml <span class="nt">--namespace</span><span class="o">=</span>limit-example
limitrange <span class="s2">"mylimits"</span> created
</code></pre></div></div>

<p>让我们查看一下在该 Namespace 中被强加的限制：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl describe limits mylimits <span class="nt">--namespace</span><span class="o">=</span>limit-example
Name:   mylimits
Namespace:  limit-example
Type        Resource      Min      Max      Default Request      Default Limit      Max Limit/Request Ratio
<span class="nt">----</span>        <span class="nt">--------</span>      <span class="nt">---</span>      <span class="nt">---</span>      <span class="nt">---------------</span>      <span class="nt">-------------</span>      <span class="nt">-----------------------</span>
Pod         cpu           200m     2        -                    -                  -
Pod         memory        6Mi      1Gi      -                    -                  -
Container   cpu           100m     2        200m                 300m               -
Container   memory        3Mi      1Gi      100Mi                200Mi              -
</code></pre></div></div>

<p>在这个场景下，指定了如下限制：</p>

<ol>
  <li>如果一个资源被指定了最大约束（在该例子中为 2 CPU 和 1Gi 内存），则必须为跨所有容器的该资源指定限制（limits）。
当尝试创建该 Pod 时，指定限额失败将导致一个验证错误。
注意，一个默认的限额通过在 <code class="highlighter-rouge">limits.yaml</code> 文件中的 <em>default</em> 来设置（300m CPU 和 200Mi 内存）。</li>
  <li>如果一个资源被指定了最小约束（在该例子中为 100m CPU 和 3Mi 内存），则必须跨所有容器的该资源指定请求（requests）。
当尝试创建该 Pod 时，指定的请求失败将导致一个验证错误。
注意，一个默认的请求的值通过在 <code class="highlighter-rouge">limits.yaml</code> 文件中的 <em>defaultRequest</em> 来设置（200m CPU 和 100Mi 内存）。</li>
  <li>对任意 Pod，所有容器内存 requests 值之和必须 &gt;= 6Mi，所有容器内存 limits 值之和必须 &lt;= 1Gi；
所有容器 CPU requests 值之和必须 &gt;= 200m，所有容器 CPU limits 值之和必须 &lt;= 2。</li>
</ol>

<h2 id="创建时强制设置限制">创建时强制设置限制</h2>

<p>当集群中的 Pod 创建和更新时，在一个 Namespace 中列出的限额是强制设置的。
如果将该限额修改成一个不同的值范围，它不会影响先前在该 Namespace 中创建的 Pod。</p>

<p>如果资源（CPU 或内存）被设置限额，用户将在创建时得到一个错误，并指出了错误的原因。</p>

<p>首先让我们启动一个 <a href="/docs/concepts/workloads/controllers/deployment/">Deployment</a>，它创建一个单容器 Pod，演示了如何将默认值应用到每个 Pod 上：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl run nginx <span class="nt">--image</span><span class="o">=</span>nginx <span class="nt">--replicas</span><span class="o">=</span>1 <span class="nt">--namespace</span><span class="o">=</span>limit-example
deployment <span class="s2">"nginx"</span> created
</code></pre></div></div>

<p>注意，在 &gt;= v1.2 版本的 Kubernetes 集群中，<code class="highlighter-rouge">kubectl run</code> 创建了名称为 “nginx” 的 Deployment。如果在老版本的集群上运行，相反它会创建 ReplicationController。
如果想要获取老版本的行为，使用 <code class="highlighter-rouge">--generator=run/v1</code> 选项来创建 ReplicationController。查看 <a href="/docs/user-guide/kubectl/v1.6/#run"><code class="highlighter-rouge">kubectl run</code></a> 获取更多详细信息。
Deployment 管理单容器 Pod 的 1 个副本。让我们看一下它是如何管理 Pod 的。首先，查找到 Pod 的名称：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl get pods <span class="nt">--namespace</span><span class="o">=</span>limit-example
NAME                     READY     STATUS    RESTARTS   AGE
nginx-2040093540-s8vzu   1/1       Running   0          11s
</code></pre></div></div>

<p>以 yaml 输出格式来打印这个 Pod，然后 <code class="highlighter-rouge">grep</code> 其中的 <code class="highlighter-rouge">resources</code> 字段。注意，您自己的 Pod 的名称将不同于上面输出的：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl get pods nginx-2040093540-s8vzu <span class="nt">--namespace</span><span class="o">=</span>limit-example <span class="nt">-o</span> yaml | <span class="nb">grep </span>resources <span class="nt">-C</span> 8
  resourceVersion: <span class="s2">"57"</span>
  selfLink: /api/v1/namespaces/limit-example/pods/nginx-2040093540-ivimu
  uid: 67b20741-f53b-11e5-b066-64510658e388
spec:
  containers:
  - image: nginx
    imagePullPolicy: Always
    name: nginx
    resources:
      limits:
        cpu: 300m
        memory: 200Mi
      requests:
        cpu: 200m
        memory: 100Mi
    terminationMessagePath: /dev/termination-log
    volumeMounts:
</code></pre></div></div>

<p>注意，我们的 Nginx 容器已经使用了 Namespace 的默认 CPU 和内存资源的 <em>limits</em> 和 <em>requests</em>。</p>

<p>让我们创建一个 Pod，它具有一个请求 3 CPU 核心的容器，这超过了被允许的限额：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl create <span class="nt">-f</span> https://k8s.io/docs/tasks/configure-pod-container/invalid-pod.yaml <span class="nt">--namespace</span><span class="o">=</span>limit-example
Error from server: error when creating <span class="s2">"http://k8s.io/docs/tasks/configure-pod-container/invalid-pod.yaml"</span>: Pod <span class="s2">"invalid-pod"</span> is forbidden: <span class="o">[</span>Maximum cpu usage per Pod is 2, but limit is 3., Maximum cpu usage per Container is 2, but limit is 3.]
</code></pre></div></div>

<p>让我们创建一个 Pod，使它在允许的最大限额范围之内：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl create <span class="nt">-f</span> https://k8s.io/docs/tasks/configure-pod-container/valid-pod.yaml <span class="nt">--namespace</span><span class="o">=</span>limit-example
pod <span class="s2">"valid-pod"</span> created
</code></pre></div></div>

<p>现在查看该 Pod 的 resources 字段：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl get pods valid-pod <span class="nt">--namespace</span><span class="o">=</span>limit-example <span class="nt">-o</span> yaml | <span class="nb">grep</span> <span class="nt">-C</span> 6 resources
  uid: 3b1bfd7a-f53c-11e5-b066-64510658e388
spec:
  containers:
  - image: gcr.io/google_containers/serve_hostname
    imagePullPolicy: Always
    name: kubernetes-serve-hostname
    resources:
      limits:
        cpu: <span class="s2">"1"</span>
        memory: 512Mi
      requests:
        cpu: <span class="s2">"1"</span>
        memory: 512Mi
</code></pre></div></div>

<p>注意到这个 Pod 显式地指定了资源 <em>limits</em> 和 <em>requests</em>，所以它不会使用该 Namespace 的默认值。</p>

<p>注意：在物理节点上默认安装的 Kubernetes 集群中，CPU 资源的 <em>limits</em> 是被强制使用的，该 Kubernetes 集群运行容器，除非管理员在部署 kublet 时使用了如下标志：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubelet <span class="nt">--help</span>
Usage of kubelet
....
  <span class="nt">--cpu-cfs-quota</span><span class="o">[=</span><span class="nb">true</span><span class="o">]</span>: Enable CPU CFS quota enforcement <span class="k">for </span>containers that specify CPU limits
<span class="nv">$ </span>kubelet <span class="nt">--cpu-cfs-quota</span><span class="o">=</span><span class="nb">false</span> ...
</code></pre></div></div>

<h2 id="清理">清理</h2>

<p>基于使用的该示例来清理资源，可以通过如下命令删除名称为 limit-example 的 Namespace：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl delete namespace limit-example
namespace <span class="s2">"limit-example"</span> deleted
<span class="nv">$ </span>kubectl get namespaces
NAME            STATUS        AGE
default         Active        12m
</code></pre></div></div>

<h2 id="设置资限额制的动机">设置资限额制的动机</h2>

<p>可能由于对资源使用的各种原因，用户希望对单个 Pod 的资源总量进行强制限制。</p>

<p>例如：</p>

<ol>
  <li>集群中每个节点有 2GB 内存。集群操作员不想接受内存需求大于 2GB 的 Pod，因为集群中没有节点能支持这个要求。
为了避免 Pod 永远无法被调度到集群中的节点上，操作员会选择去拒绝超过 2GB 内存作为许可控制的 Pod。</li>
  <li>一个集群被一个组织内部的 2 个团体共享，分别作为生产和开发工作负载来运行。
生产工作负载可能消耗多达 8GB 内存，而开发工作负载可能消耗 512MB 内存。
集群操作员为每个工作负载创建了一个单独的 Namespace，为每个 Namespace 设置了限额。</li>
  <li>用户会可能创建一个资源消耗低于机器容量的 Pod。剩余的空间可能太小但很有用，然而对于整个集群来说浪费的代价是足够大的。
结果集群操作员会希望设置限额：为了统一调度和限制浪费，Pod 必须至少消耗它们平均节点大小 20% 的内存和 CPU。</li>
</ol>

<h2 id="总结">总结</h2>

<p>想要限制单个容器或 Pod 消耗资源总量的集群操作员，能够为每个 Kubernetes Namespace 定义可允许的范围。
在没有任何明确指派的情况下，Kubernetes 系统能够使用默认的资源 <em>limits</em> 和 <em>requests</em>，如果需要的话，限制一个节点上的 Pod 的资源总量。</p>

<h2 id="whats-next">What’s next</h2>

<ul>
  <li>查看 <a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/resource-management/admission_control_limit_range.md">LimitRange 设计文档</a> 获取更多信息。</li>
  <li>查看 <a href="/docs/concepts/configuration/manage-compute-resources-container/">资源</a> 获取关于 Kubernetes 资源模型的详细描述。</li>
</ul>

