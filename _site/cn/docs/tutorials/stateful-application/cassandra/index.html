<h2 id="目录">目录</h2>

<ul>
  <li><a href="#prerequisites">准备工作</a></li>
  <li><a href="#cassandra-docker">Cassandra docker 镜像</a></li>
  <li><a href="#quickstart">快速入门</a></li>
  <li><a href="#step-1-create-a-cassandra-headless-service">步骤1：创建 Cassandra Headless Service</a></li>
  <li><a href="#step-2-use-a-statefulset-to-create-cassandra-ring">步骤2：使用 StatefulSet 创建 Cassandra Ring环</a></li>
  <li><a href="#step-3-validate-and-modify-the-cassandra-statefulset">步骤3：验证并修改 Cassandra StatefulSet</a></li>
  <li><a href="#step-4-delete-cassandra-statefulset">步骤4：删除 Cassandra StatefulSet</a></li>
  <li><a href="#step-5-use-a-replication-controller-to-create-cassandra-node-pods">步骤5：使用 Replication Controller 创建 Cassandra 节点 pods</a></li>
  <li><a href="#step-6-scale-up-the-cassandra-cluster">步骤6：Cassandra 集群扩容</a></li>
  <li><a href="#step-7-delete-the-replication-controller">步骤7：删除 Replication Controller</a></li>
  <li><a href="#step-8-use-a-daemonset-instead-of-a-replication-controller">步骤8：使用 DaemonSet 替换 Replication Controller</a></li>
  <li><a href="#step-9-resource-cleanup">步骤9：资源清理</a></li>
  <li><a href="#seed-provider-source">Seed Provider Source</a></li>
</ul>

<p>下文描述了在 Kubernetes 上部署一个_云原生_ <a href="http://cassandra.apache.org/">Cassandra</a> 的过程。当我们说_云原生_时，指的是一个应用能够理解它运行在一个集群管理器内部，并且使用这个集群的管理基础设施来帮助实现这个应用。特别的，本例使用了一个自定义的 Cassandra <code class="highlighter-rouge">SeedProvider</code> 帮助 Cassandra 发现新加入集群 Cassandra 节点。</p>

<p>本示例也使用了Kubernetes的一些核心组件：</p>

<ul>
  <li><a href="/docs/user-guide/pods"><em>Pods</em></a></li>
  <li><a href="/docs/user-guide/services"> <em>Services</em></a></li>
  <li><a href="/docs/user-guide/replication-controller"><em>Replication Controllers</em></a></li>
  <li><a href="/docs/concepts/workloads/controllers/statefulset/"><em>Stateful Sets</em></a></li>
  <li><a href="/docs/admin/daemons"><em>Daemon Sets</em></a></li>
</ul>

<h2 id="准备工作">准备工作</h2>

<p>本示例假设你已经安装运行了一个 Kubernetes集群（版本 &gt;=1.2），并且还在某个路径下安装了  <a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/"><code class="highlighter-rouge">kubectl</code></a> 命令行工具。请查看 <a href="https://kubernetes.io/docs/getting-started-guides/">getting started guides</a> 获取关于你的平台的安装说明。</p>

<p>本示例还需要一些代码和配置文件。为了避免手动输入，你可以 <code class="highlighter-rouge">git clone</code> Kubernetes 源到你本地。</p>

<h2 id="cassandra-docker镜像">Cassandra Docker镜像</h2>

<p>Pods 使用来自  Google 的 <a href="https://cloud.google.com/container-registry/docs/">container registry</a> 的  <a href="https://github.com/kubernetes/examples/blob/master/cassandra/image/Dockerfile"><code class="highlighter-rouge">gcr.io/google-samples/cassandra:v12</code></a> 镜像。这个 docker 镜像基于 <code class="highlighter-rouge">debian:jessie</code> 并包含 OpenJDK 8。该镜像包含一个从  Apache Debian 源中安装的标准 Cassandra。你可以通过使用环境变量改变插入到 <code class="highlighter-rouge">cassandra.yaml</code> 文件中的参数值。</p>

<table>
  <thead>
    <tr>
      <th>ENV VAR</th>
      <th style="text-align: center">DEFAULT VALUE</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>CASSANDRA_CLUSTER_NAME</td>
      <td style="text-align: center">‘Test Cluster’</td>
    </tr>
    <tr>
      <td>CASSANDRA_NUM_TOKENS</td>
      <td style="text-align: center">32</td>
    </tr>
    <tr>
      <td>CASSANDRA_RPC_ADDRESS</td>
      <td style="text-align: center">0.0.0.0</td>
    </tr>
  </tbody>
</table>

<h2 id="快速入门">快速入门</h2>

<p>如果你希望直接跳到我们使用的命令，以下是全部步骤：</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#</span>
<span class="c"># StatefulSet</span>
<span class="c">#</span>

<span class="c"># clone the example repository</span>
git clone https://github.com/kubernetes/examples
<span class="nb">cd </span>examples

<span class="c"># create a service to track all cassandra statefulset nodes</span>
kubectl create <span class="nt">-f</span> cassandra/cassandra-service.yaml

<span class="c"># create a statefulset</span>
kubectl create <span class="nt">-f</span> cassandra/cassandra-statefulset.yaml

<span class="c"># validate the Cassandra cluster. Substitute the name of one of your pods.</span>
kubectl <span class="nb">exec</span> <span class="nt">-ti</span> cassandra-0 <span class="nt">--</span> nodetool status

<span class="c"># cleanup</span>
<span class="nv">grace</span><span class="o">=</span><span class="k">$(</span>kubectl get po cassandra-0 <span class="nt">-o</span><span class="o">=</span><span class="nv">jsonpath</span><span class="o">=</span><span class="s1">'{.spec.terminationGracePeriodSeconds}'</span><span class="k">)</span> <span class="se">\</span>
  <span class="o">&amp;&amp;</span> kubectl delete statefulset,po <span class="nt">-l</span> <span class="nv">app</span><span class="o">=</span>cassandra <span class="se">\</span>
  <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s2">"Sleeping </span><span class="nv">$grace</span><span class="s2">"</span> <span class="se">\</span>
  <span class="o">&amp;&amp;</span> sleep <span class="nv">$grace</span> <span class="se">\</span>
  <span class="o">&amp;&amp;</span> kubectl delete pvc <span class="nt">-l</span> <span class="nv">app</span><span class="o">=</span>cassandra

<span class="c">#</span>
<span class="c"># Resource Controller Example</span>
<span class="c">#</span>

<span class="c"># create a replication controller to replicate cassandra nodes</span>
kubectl create <span class="nt">-f</span> cassandra/cassandra-controller.yaml

<span class="c"># validate the Cassandra cluster. Substitute the name of one of your pods.</span>
kubectl <span class="nb">exec</span> <span class="nt">-ti</span> cassandra-xxxxx <span class="nt">--</span> nodetool status

<span class="c"># scale up the Cassandra cluster</span>
kubectl scale rc cassandra <span class="nt">--replicas</span><span class="o">=</span>4

<span class="c"># delete the replication controller</span>
kubectl delete rc cassandra

<span class="c">#</span>
<span class="c"># Create a DaemonSet to place a cassandra node on each kubernetes node</span>
<span class="c">#</span>

kubectl create <span class="nt">-f</span> cassandra/cassandra-daemonset.yaml <span class="nt">--validate</span><span class="o">=</span><span class="nb">false</span>

<span class="c"># resource cleanup</span>
kubectl delete service <span class="nt">-l</span> <span class="nv">app</span><span class="o">=</span>cassandra
kubectl delete daemonset cassandra
</code></pre></div></div>

<h2 id="步骤1创建-cassandra-headless-service">步骤1：创建 Cassandra Headless Service</h2>

<p>Kubernetes <em><a href="/docs/user-guide/services">Service</a></em> 描述一组执行同样任务的 <a href="/docs/user-guide/pods"><em>Pods</em></a>。在Kubernetes中，一个应用的原子调度单位是一个 Pod：一个或多个_必须_调度到相同主机上的容器。</p>

<p>这个 Service 用于在Kubernetes 集群内部进行 Cassandra 客户端和 Cassandra Pods之间的 DNS 查找。</p>

<p>以下为这个 service 的描述：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Service</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">labels</span><span class="pi">:</span>
    <span class="na">app</span><span class="pi">:</span> <span class="s">cassandra</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">cassandra</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">clusterIP</span><span class="pi">:</span> <span class="s">None</span>
  <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">port</span><span class="pi">:</span> <span class="s">9042</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">app</span><span class="pi">:</span> <span class="s">cassandra</span>
</code></pre></div></div>

<p><a href="https://raw.githubusercontent.com/kubernetes/examples/master/cassandra-service.yaml">下载示例</a></p>

<p>为 StatefulSet 创建 service</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> kubectl create <span class="nt">-f</span> cassandra/cassandra-service.yaml
</code></pre></div></div>

<p>以下命令显示了 service 是否被成功创建。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> kubectl get svc cassandra
</code></pre></div></div>

<p>命令的响应应该像这样：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">NAME        CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE
</span><span class="gp">cassandra   None         &lt;none&gt;</span>        9042/TCP   45s
</code></pre></div></div>

<p>如果返回错误则表示 service 创建失败。</p>

<h2 id="步骤2使用-statefulset-创建--cassandra-ring环">步骤2：使用 StatefulSet 创建  Cassandra Ring环</h2>

<p>StatefulSets（以前叫做 PetSets）特性在 Kubernetes 1.5 中升级为一个 <em>Beta</em> 组件。在集群环境中部署类似于 Cassandra 的有状态分布式应用是一项具有挑战性的工作。我们实现了StatefulSet，极大的简化了这个过程。本示例使用了 StatefulSet 的多个特性，但其本身超出了本文的范围。<a href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/">请参考 Stateful Set 文档。</a></p>

<p>以下是StatefulSet 的清单文件，用于创建一个由三个 pods 组成的 Cassandra ring环。</p>

<p>本示例使用了 GCE Storage Class，请根据你运行的云平台做适当的修改。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s2">"</span><span class="s">apps/v1beta1"</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">StatefulSet</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">cassandra</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">serviceName</span><span class="pi">:</span> <span class="s">cassandra</span>
  <span class="na">replicas</span><span class="pi">:</span> <span class="s">3</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">cassandra</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">containers</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">cassandra</span>
        <span class="na">image</span><span class="pi">:</span> <span class="s">gcr.io/google-samples/cassandra:v12</span>
        <span class="na">imagePullPolicy</span><span class="pi">:</span> <span class="s">Always</span>
        <span class="na">ports</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="s">7000</span>
          <span class="na">name</span><span class="pi">:</span> <span class="s">intra-node</span>
        <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="s">7001</span>
          <span class="na">name</span><span class="pi">:</span> <span class="s">tls-intra-node</span>
        <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="s">7199</span>
          <span class="na">name</span><span class="pi">:</span> <span class="s">jmx</span>
        <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="s">9042</span>
          <span class="na">name</span><span class="pi">:</span> <span class="s">cql</span>
        <span class="na">resources</span><span class="pi">:</span>
          <span class="na">limits</span><span class="pi">:</span>
            <span class="na">cpu</span><span class="pi">:</span> <span class="s2">"</span><span class="s">500m"</span>
            <span class="na">memory</span><span class="pi">:</span> <span class="s">1Gi</span>
          <span class="na">requests</span><span class="pi">:</span>
           <span class="na">cpu</span><span class="pi">:</span> <span class="s2">"</span><span class="s">500m"</span>
           <span class="na">memory</span><span class="pi">:</span> <span class="s">1Gi</span>
        <span class="na">securityContext</span><span class="pi">:</span>
          <span class="na">capabilities</span><span class="pi">:</span>
            <span class="na">add</span><span class="pi">:</span>
              <span class="pi">-</span> <span class="s">IPC_LOCK</span>
        <span class="na">lifecycle</span><span class="pi">:</span>
          <span class="na">preStop</span><span class="pi">:</span>
            <span class="na">exec</span><span class="pi">:</span>
              <span class="na">command</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">/bin/sh"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">-c"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">PID=$(pidof</span><span class="nv"> </span><span class="s">java)</span><span class="nv"> </span><span class="s">&amp;&amp;</span><span class="nv"> </span><span class="s">kill</span><span class="nv"> </span><span class="s">$PID</span><span class="nv"> </span><span class="s">&amp;&amp;</span><span class="nv"> </span><span class="s">while</span><span class="nv"> </span><span class="s">ps</span><span class="nv"> </span><span class="s">-p</span><span class="nv"> </span><span class="s">$PID</span><span class="nv"> </span><span class="s">&gt;</span><span class="nv"> </span><span class="s">/dev/null;</span><span class="nv"> </span><span class="s">do</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">1;</span><span class="nv"> </span><span class="s">done"</span><span class="pi">]</span>
        <span class="na">env</span><span class="pi">:</span>
          <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">MAX_HEAP_SIZE</span>
            <span class="na">value</span><span class="pi">:</span> <span class="s">512M</span>
          <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">HEAP_NEWSIZE</span>
            <span class="na">value</span><span class="pi">:</span> <span class="s">100M</span>
          <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">CASSANDRA_SEEDS</span>
            <span class="na">value</span><span class="pi">:</span> <span class="s2">"</span><span class="s">cassandra-0.cassandra.default.svc.cluster.local"</span>
          <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">CASSANDRA_CLUSTER_NAME</span>
            <span class="na">value</span><span class="pi">:</span> <span class="s2">"</span><span class="s">K8Demo"</span>
          <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">CASSANDRA_DC</span>
            <span class="na">value</span><span class="pi">:</span> <span class="s2">"</span><span class="s">DC1-K8Demo"</span>
          <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">CASSANDRA_RACK</span>
            <span class="na">value</span><span class="pi">:</span> <span class="s2">"</span><span class="s">Rack1-K8Demo"</span>
          <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">CASSANDRA_AUTO_BOOTSTRAP</span>
            <span class="na">value</span><span class="pi">:</span> <span class="s2">"</span><span class="s">false"</span>
          <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">POD_IP</span>
            <span class="na">valueFrom</span><span class="pi">:</span>
              <span class="na">fieldRef</span><span class="pi">:</span>
                <span class="na">fieldPath</span><span class="pi">:</span> <span class="s">status.podIP</span>
        <span class="na">readinessProbe</span><span class="pi">:</span>
          <span class="na">exec</span><span class="pi">:</span>
            <span class="na">command</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="s">/bin/bash</span>
            <span class="pi">-</span> <span class="s">-c</span>
            <span class="pi">-</span> <span class="s">/ready-probe.sh</span>
          <span class="na">initialDelaySeconds</span><span class="pi">:</span> <span class="s">15</span>
          <span class="na">timeoutSeconds</span><span class="pi">:</span> <span class="s">5</span>
        <span class="c1"># These volume mounts are persistent. They are like inline claims,</span>
        <span class="c1"># but not exactly because the names need to match exactly one of</span>
        <span class="c1"># the stateful pod volumes.</span>
        <span class="na">volumeMounts</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">cassandra-data</span>
          <span class="na">mountPath</span><span class="pi">:</span> <span class="s">/cassandra_data</span>
  <span class="c1"># These are converted to volume claims by the controller</span>
  <span class="c1"># and mounted at the paths mentioned above.</span>
  <span class="c1"># do not use these in production until ssd GCEPersistentDisk or other ssd pd</span>
  <span class="na">volumeClaimTemplates</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">name</span><span class="pi">:</span> <span class="s">cassandra-data</span>
      <span class="na">annotations</span><span class="pi">:</span>
        <span class="s">volume.beta.kubernetes.io/storage-class</span><span class="pi">:</span> <span class="s">fast</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">accessModes</span><span class="pi">:</span> <span class="pi">[</span> <span class="s2">"</span><span class="s">ReadWriteOnce"</span> <span class="pi">]</span>
      <span class="na">resources</span><span class="pi">:</span>
        <span class="na">requests</span><span class="pi">:</span>
          <span class="na">storage</span><span class="pi">:</span> <span class="s">1Gi</span>
<span class="nn">---</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">StorageClass</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">storage.k8s.io/v1beta1</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">fast</span>
<span class="na">provisioner</span><span class="pi">:</span> <span class="s">kubernetes.io/gce-pd</span>
<span class="na">parameters</span><span class="pi">:</span>
  <span class="na">type</span><span class="pi">:</span> <span class="s">pd-ssd</span>
</code></pre></div></div>

<p><a href="https://raw.githubusercontent.com/kubernetes/examples/master/cassandra-statefulset.yaml">下载示例</a></p>

<p>创建  Cassandra StatefulSet 如下：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> kubectl create <span class="nt">-f</span> cassandra/cassandra-statefulset.yaml
</code></pre></div></div>

<h2 id="步骤3验证和修改-cassandra-statefulset">步骤3：验证和修改 Cassandra StatefulSet</h2>

<p>这个 StatefulSet 的部署展示了 StatefulSets 提供的两个新特性：</p>

<ol>
  <li>Pod 的名称已知</li>
  <li>Pod 以递增顺序部署</li>
</ol>

<p>首先，运行下面的 <code class="highlighter-rouge">kubectl</code> 命令，验证 StatefulSet 已经被成功部署。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> kubectl get statefulset cassandra
</code></pre></div></div>

<p>这个命令的响应应该像这样：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">NAME        DESIRED   CURRENT   AGE
cassandra   3         3         13s
</span></code></pre></div></div>

<p>接下来观察 Cassandra pods 以一个接一个的形式部署。StatefulSet 资源按照数字序号的模式部署 pods：1, 2, 3 等。如果在 pods 部署前执行下面的命令，你就能够看到这种顺序的创建过程。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> kubectl get pods <span class="nt">-l</span><span class="o">=</span><span class="s2">"app=cassandra"</span>
<span class="go">NAME          READY     STATUS              RESTARTS   AGE
cassandra-0   1/1       Running             0          1m
cassandra-1   0/1       ContainerCreating   0          8s
</span></code></pre></div></div>

<p>上面的示例显示了三个 Cassandra StatefulSet pods 中的两个已经部署。一旦所有的 pods 都部署成功，相同的命令会显示一个完整的StatefulSet。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> kubectl get pods <span class="nt">-l</span><span class="o">=</span><span class="s2">"app=cassandra"</span>
<span class="go">NAME          READY     STATUS    RESTARTS   AGE
cassandra-0   1/1       Running   0          10m
cassandra-1   1/1       Running   0          9m
cassandra-2   1/1       Running   0          8m
</span></code></pre></div></div>

<p>运行 Cassandra 工具 <code class="highlighter-rouge">nodetool</code> 将显示 ring环的状态。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> kubectl <span class="nb">exec </span>cassandra-0 <span class="nt">--</span> nodetool status
<span class="go">Datacenter: DC1-K8Demo
======================
Status=Up/Down
|/ State=Normal/Leaving/Joining/Moving
--  Address   Load       Tokens       Owns (effective)  Host ID                               Rack
UN  10.4.2.4  65.26 KiB  32           63.7%             a9d27f81-6783-461d-8583-87de2589133e  Rack1-K8Demo
UN  10.4.0.4  102.04 KiB  32           66.7%             5559a58c-8b03-47ad-bc32-c621708dc2e4  Rack1-K8Demo
UN  10.4.1.4  83.06 KiB  32           69.6%             9dce943c-581d-4c0e-9543-f519969cc805  Rack1-K8Demo
</span></code></pre></div></div>

<p>你也可以运行 <code class="highlighter-rouge">cqlsh</code> 来显示集群的 keyspaces。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> kubectl <span class="nb">exec </span>cassandra-0 <span class="nt">--</span> cqlsh <span class="nt">-e</span> <span class="s1">'desc keyspaces'</span>
<span class="go">
system_traces  system_schema  system_auth  system  system_distributed
</span></code></pre></div></div>

<p>你需要使用 <code class="highlighter-rouge">kubectl edit</code> 来增加或减小 Cassandra StatefulSet 的大小。你可以在 <a href="/docs/user-guide/kubectl/kubectl_edit">文档</a> 中找到更多关于 edit 命令的信息。</p>

<p>使用以下命令编辑 StatefulSet。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> kubectl edit statefulset cassandra
</code></pre></div></div>

<p>这会在你的命令行中创建一个编辑器。你需要修改的行是 <code class="highlighter-rouge">replicas</code>。这个例子没有包含终端窗口的所有内容，下面示例中的最后一行就是你希望改变的 replicas 行。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">#</span> Please edit the object below. Lines beginning with a <span class="s1">'#'</span> will be ignored,
<span class="gp">#</span> and an empty file will abort the edit. If an error occurs <span class="k">while </span>saving this file will be
<span class="gp">#</span> reopened with the relevant failures.
<span class="gp">#</span>
<span class="go">apiVersion: apps/v1beta1
kind: StatefulSet
metadata:
  creationTimestamp: 2016-08-13T18:40:58Z
  generation: 1
  labels:
    app: cassandra
  name: cassandra
  namespace: default
  resourceVersion: "323"
  selfLink: /apis/apps/v1beta1/namespaces/default/statefulsets/cassandra
  uid: 7a219483-6185-11e6-a910-42010a8a0fc0
spec:
  replicas: 3
</span></code></pre></div></div>

<p>按下面的示例修改清单文件并保存。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">spec:
  replicas: 4
</span></code></pre></div></div>

<p>这个 StatefulSet 现在将包含四个 pods。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> kubectl get statefulset cassandra
</code></pre></div></div>

<p>这个command的响应应该像这样：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">NAME        DESIRED   CURRENT   AGE
cassandra   4         4         36m
</span></code></pre></div></div>

<p>对于 Kubernetes 1.5 发布版，beta StatefulSet 资源没有像 Deployment, ReplicaSet, Replication Controller或者 Job一样，包含 <code class="highlighter-rouge">kubectl scale</code> 功能，</p>

<h2 id="步骤4删除-cassandra-statefulset">步骤4：删除 Cassandra StatefulSet</h2>

<p>删除或者缩容 StatefulSet 时不会删除与之关联的 volumes。这样做是为了优先保证安全。你的数据比其它会被自动清除的 StatefulSet 关联资源更宝贵。删除 Persistent Volume Claims 可能会导致关联的 volumes 被删除，这种行为依赖 storage class 和 reclaim policy。永远不要期望能在 claim 删除后访问一个 volume。</p>

<p>使用如下命令删除 StatefulSet。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> <span class="nv">grace</span><span class="o">=</span><span class="k">$(</span>kubectl get po cassandra-0 <span class="nt">-o</span><span class="o">=</span><span class="nv">jsonpath</span><span class="o">=</span><span class="s1">'{.spec.terminationGracePeriodSeconds}'</span><span class="k">)</span> <span class="se">\</span>
  <span class="o">&amp;&amp;</span> kubectl delete statefulset <span class="nt">-l</span> <span class="nv">app</span><span class="o">=</span>cassandra <span class="se">\</span>
  <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s2">"Sleeping </span><span class="nv">$grace</span><span class="s2">"</span> <span class="se">\</span>
  <span class="o">&amp;&amp;</span> sleep <span class="nv">$grace</span> <span class="se">\</span>
  <span class="o">&amp;&amp;</span> kubectl delete pvc <span class="nt">-l</span> <span class="nv">app</span><span class="o">=</span>cassandra
</code></pre></div></div>

<h2 id="步骤5使用-replication-controller-创建-cassandra-节点-pods">步骤5：使用 Replication Controller 创建 Cassandra 节点 pods</h2>

<p>Kubernetes <em><a href="/docs/user-guide/replication-controller">Replication Controller</a></em> 负责复制一个完全相同的 pods 集合。像 Service 一样，它具有一个 selector query，用来识别它的集合成员。和 Service 不一样的是，它还具有一个期望的副本数，并且会通过创建或删除 Pods来保证 Pods 的数量满足它期望的状态。</p>

<p>和我们刚才定义的 Service 一起，Replication Controller 能够让我们轻松的构建一个复制的、可扩展的 Cassandra 集群。</p>

<p>让我们创建一个具有两个初始副本的  replication controller。</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">ReplicationController</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">cassandra</span>
  <span class="c1"># The labels will be applied automatically</span>
  <span class="c1"># from the labels in the pod template, if not set</span>
  <span class="c1"># labels:</span>
    <span class="c1"># app: cassandra</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">replicas</span><span class="pi">:</span> <span class="s">2</span>
  <span class="c1"># The selector will be applied automatically</span>
  <span class="c1"># from the labels in the pod template, if not set.</span>
  <span class="c1"># selector:</span>
      <span class="c1"># app: cassandra</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">cassandra</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">containers</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">command</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="s">/run.sh</span>
          <span class="na">resources</span><span class="pi">:</span>
            <span class="na">limits</span><span class="pi">:</span>
              <span class="na">cpu</span><span class="pi">:</span> <span class="s">0.5</span>
          <span class="na">env</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">MAX_HEAP_SIZE</span>
              <span class="na">value</span><span class="pi">:</span> <span class="s">512M</span>
            <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">HEAP_NEWSIZE</span>
              <span class="na">value</span><span class="pi">:</span> <span class="s">100M</span>
            <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">CASSANDRA_SEED_PROVIDER</span>
              <span class="na">value</span><span class="pi">:</span> <span class="s2">"</span><span class="s">io.k8s.cassandra.KubernetesSeedProvider"</span>
            <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">POD_NAMESPACE</span>
              <span class="na">valueFrom</span><span class="pi">:</span>
                <span class="na">fieldRef</span><span class="pi">:</span>
                  <span class="na">fieldPath</span><span class="pi">:</span> <span class="s">metadata.namespace</span>
            <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">POD_IP</span>
              <span class="na">valueFrom</span><span class="pi">:</span>
                <span class="na">fieldRef</span><span class="pi">:</span>
                  <span class="na">fieldPath</span><span class="pi">:</span> <span class="s">status.podIP</span>
          <span class="na">image</span><span class="pi">:</span> <span class="s">gcr.io/google-samples/cassandra:v12</span>
          <span class="na">name</span><span class="pi">:</span> <span class="s">cassandra</span>
          <span class="na">ports</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="s">7000</span>
              <span class="na">name</span><span class="pi">:</span> <span class="s">intra-node</span>
            <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="s">7001</span>
              <span class="na">name</span><span class="pi">:</span> <span class="s">tls-intra-node</span>
            <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="s">7199</span>
              <span class="na">name</span><span class="pi">:</span> <span class="s">jmx</span>
            <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="s">9042</span>
              <span class="na">name</span><span class="pi">:</span> <span class="s">cql</span>
          <span class="na">volumeMounts</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="na">mountPath</span><span class="pi">:</span> <span class="s">/cassandra_data</span>
              <span class="na">name</span><span class="pi">:</span> <span class="s">data</span>
      <span class="na">volumes</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">data</span>
          <span class="na">emptyDir</span><span class="pi">:</span> <span class="pi">{}</span>
</code></pre></div></div>

<p><a href="https://raw.githubusercontent.com/kubernetes/examples/master/cassandra-controller.yaml">下载示例</a></p>

<p>在这个描述中需要注意几件事情。</p>

<p><code class="highlighter-rouge">selector</code> 属性包含了控制器的  selector query。它能够被显式指定，或者在没有设置时，像此处一样从 pod 模板中的 labels 中自动应用。</p>

<p>Pod 模板的标签 <code class="highlighter-rouge">app:cassandra</code> 匹配步骤1中的 Service selector。这就是 Service  如何选择 replication controller 创建的 pods 的原理。</p>

<p><code class="highlighter-rouge">replicas</code> 属性指明了期望的副本数量，在本例中最开始为 2。我们很快将要扩容更多数量。</p>

<p>创建 Replication Controller：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">
</span><span class="gp">$</span> kubectl create <span class="nt">-f</span> cassandra/cassandra-controller.yaml
<span class="go">
</span></code></pre></div></div>

<p>你可以列出新建的 controller：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">
</span><span class="gp">$</span> kubectl get rc <span class="nt">-o</span> wide
<span class="go">NAME        DESIRED   CURRENT   AGE       CONTAINER(S)   IMAGE(S)                             SELECTOR
cassandra   2         2         11s       cassandra      gcr.io/google-samples/cassandra:v12   app=cassandra

</span></code></pre></div></div>

<p>现在，如果你列出集群中的 pods，并且使用 <code class="highlighter-rouge">app=cassandra</code> 标签过滤，你应该能够看到两个 Cassandra pods。（<code class="highlighter-rouge">wide</code> 参数使你能够看到 pods 被调度到了哪个 Kubernetes 节点上）</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">
</span><span class="gp">$</span> kubectl get pods <span class="nt">-l</span><span class="o">=</span><span class="s2">"app=cassandra"</span> <span class="nt">-o</span> wide
<span class="go">NAME              READY     STATUS    RESTARTS   AGE       NODE
cassandra-21qyy   1/1       Running   0          1m        kubernetes-minion-b286
cassandra-q6sz7   1/1       Running   0          1m        kubernetes-minion-9ye5

</span></code></pre></div></div>

<p>因为这些 pods 拥有 <code class="highlighter-rouge">app=cassandra</code> 标签，它们被映射给了我们在步骤1中创建的 service。</p>

<p>你可以使用下面的 service endpoint 查询命令来检查 Pods 是否对 Service 可用。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">
</span><span class="gp">$</span> kubectl get endpoints cassandra <span class="nt">-o</span> yaml
<span class="go">apiVersion: v1
kind: Endpoints
metadata:
  creationTimestamp: 2015-06-21T22:34:12Z
  labels:
    app: cassandra
  name: cassandra
  namespace: default
  resourceVersion: "944373"
  selfLink: /api/v1/namespaces/default/endpoints/cassandra
  uid: a3d6c25f-1865-11e5-a34e-42010af01bcc
subsets:
- addresses:
  - ip: 10.244.3.15
    targetRef:
      kind: Pod
      name: cassandra
      namespace: default
      resourceVersion: "944372"
      uid: 9ef9895d-1865-11e5-a34e-42010af01bcc
  ports:
  - port: 9042
    protocol: TCP

</span></code></pre></div></div>

<p>为了显示 <code class="highlighter-rouge">SeedProvider</code> 逻辑是按设想在运行，你可以使用 <code class="highlighter-rouge">nodetool</code> 命令来检查  Cassandra 集群的状态。为此，请使用 <code class="highlighter-rouge">kubectl exec</code> 命令，这样你就能在一个 Cassandra pod 上运行 <code class="highlighter-rouge">nodetool</code>。同样的，请替换 <code class="highlighter-rouge">cassandra-xxxxx</code> 为任意一个 pods的真实名字。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">
</span><span class="gp">$</span> kubectl <span class="nb">exec</span> <span class="nt">-ti</span> cassandra-xxxxx <span class="nt">--</span> nodetool status
<span class="go">Datacenter: datacenter1
=======================
Status=Up/Down
|/ State=Normal/Leaving/Joining/Moving
--  Address     Load       Tokens  Owns (effective)  Host ID                               Rack
UN  10.244.0.5  74.09 KB   256     100.0%            86feda0f-f070-4a5b-bda1-2eeb0ad08b77  rack1
UN  10.244.3.3  51.28 KB   256     100.0%            dafe3154-1d67-42e1-ac1d-78e7e80dce2b  rack1

</span></code></pre></div></div>

<h2 id="步骤6cassandra集群扩容">步骤6：Cassandra集群扩容</h2>

<p>现在，让我们把 Cassandra 集群扩展到4个 pods。我们通过告诉 Replication Controller 现在我们需要4个副本来完成。</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nv">$ </span>kubectl scale rc cassandra <span class="nt">--replicas</span><span class="o">=</span>4

</code></pre></div></div>

<p>你可以看到列出了新的 pods：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">
</span><span class="gp">$</span> kubectl get pods <span class="nt">-l</span><span class="o">=</span><span class="s2">"app=cassandra"</span> <span class="nt">-o</span> wide
<span class="go">NAME              READY     STATUS    RESTARTS   AGE       NODE
cassandra-21qyy   1/1       Running   0          6m        kubernetes-minion-b286
cassandra-81m2l   1/1       Running   0          47s       kubernetes-minion-b286
cassandra-8qoyp   1/1       Running   0          47s       kubernetes-minion-9ye5
cassandra-q6sz7   1/1       Running   0          6m        kubernetes-minion-9ye5

</span></code></pre></div></div>

<p>一会儿你就能再次检查 Cassandra 集群的状态，你可以看到新的 pods 已经被自定义的 <code class="highlighter-rouge">SeedProvider</code> 检测到：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">
</span><span class="gp">$</span> kubectl <span class="nb">exec</span> <span class="nt">-ti</span> cassandra-xxxxx <span class="nt">--</span> nodetool status
<span class="go">Datacenter: datacenter1
=======================
Status=Up/Down
|/ State=Normal/Leaving/Joining/Moving
--  Address     Load       Tokens  Owns (effective)  Host ID                               Rack
UN  10.244.0.6  51.67 KB   256     48.9%             d07b23a5-56a1-4b0b-952d-68ab95869163  rack1
UN  10.244.1.5  84.71 KB   256     50.7%             e060df1f-faa2-470c-923d-ca049b0f3f38  rack1
UN  10.244.1.6  84.71 KB   256     47.0%             83ca1580-4f3c-4ec5-9b38-75036b7a297f  rack1
UN  10.244.0.5  68.2 KB    256     53.4%             72ca27e2-c72c-402a-9313-1e4b61c2f839  rack1

</span></code></pre></div></div>

<h2 id="步骤7删除-replication-controller">步骤7：删除 Replication Controller</h2>

<p>在你开始步骤5之前， <strong>删除__你在上面创建的 __replication controller</strong>。</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nv">$ </span>kubectl delete rc cassandra

</code></pre></div></div>

<h2 id="步骤8使用-daemonset-替换-replication-controller">步骤8：使用 DaemonSet 替换 Replication Controller</h2>

<p>在 Kubernetes中，<a href="/docs/admin/daemons"><em>Daemon Set</em></a> 能够将 pods 一对一的分布到 Kubernetes 节点上。和  <em>ReplicationController</em> 相同的是它也有一个用于识别它的集合成员的 selector query。但和 <em>ReplicationController</em> 不同的是，它拥有一个节点 selector，用于限制基于模板的 pods 可以调度的节点。并且 pod 的复制不是基于一个设置的数量，而是为每一个节点分配一个 pod。</p>

<p>示范用例：当部署到云平台时，预期情况是实例是短暂的并且随时可能终止。Cassandra 被搭建成为在各个节点间复制数据以便于实现数据冗余。这样的话，即使一个实例终止了，存储在它上面的数据却没有，并且集群会通过重新复制数据到其它运行节点来作为响应。</p>

<p><code class="highlighter-rouge">DaemonSet</code> 设计为在 Kubernetes 集群中的每个节点上放置一个 pod。那样就会给我们带来数据冗余度。让我们创建一个 DaemonSet 来启动我们的存储集群：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">extensions/v1beta1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">DaemonSet</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">labels</span><span class="pi">:</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">cassandra</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">cassandra</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">cassandra</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="c1"># Filter to specific nodes:</span>
      <span class="c1"># nodeSelector:</span>
      <span class="c1">#  app: cassandra</span>
      <span class="na">containers</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">command</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="s">/run.sh</span>
          <span class="na">env</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">MAX_HEAP_SIZE</span>
              <span class="na">value</span><span class="pi">:</span> <span class="s">512M</span>
            <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">HEAP_NEWSIZE</span>
              <span class="na">value</span><span class="pi">:</span> <span class="s">100M</span>
            <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">CASSANDRA_SEED_PROVIDER</span>
              <span class="na">value</span><span class="pi">:</span> <span class="s2">"</span><span class="s">io.k8s.cassandra.KubernetesSeedProvider"</span>
            <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">POD_NAMESPACE</span>
              <span class="na">valueFrom</span><span class="pi">:</span>
                <span class="na">fieldRef</span><span class="pi">:</span>
                  <span class="na">fieldPath</span><span class="pi">:</span> <span class="s">metadata.namespace</span>
            <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">POD_IP</span>
              <span class="na">valueFrom</span><span class="pi">:</span>
                <span class="na">fieldRef</span><span class="pi">:</span>
                  <span class="na">fieldPath</span><span class="pi">:</span> <span class="s">status.podIP</span>
          <span class="na">image</span><span class="pi">:</span> <span class="s">gcr.io/google-samples/cassandra:v12</span>
          <span class="na">name</span><span class="pi">:</span> <span class="s">cassandra</span>
          <span class="na">ports</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="s">7000</span>
              <span class="na">name</span><span class="pi">:</span> <span class="s">intra-node</span>
            <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="s">7001</span>
              <span class="na">name</span><span class="pi">:</span> <span class="s">tls-intra-node</span>
            <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="s">7199</span>
              <span class="na">name</span><span class="pi">:</span> <span class="s">jmx</span>
            <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="s">9042</span>
              <span class="na">name</span><span class="pi">:</span> <span class="s">cql</span>
              <span class="c1"># If you need it it is going away in C* 4.0</span>
              <span class="c1">#- containerPort: 9160</span>
              <span class="c1">#  name: thrift</span>
          <span class="na">resources</span><span class="pi">:</span>
            <span class="na">requests</span><span class="pi">:</span>
              <span class="na">cpu</span><span class="pi">:</span> <span class="s">0.5</span>
          <span class="na">volumeMounts</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="na">mountPath</span><span class="pi">:</span> <span class="s">/cassandra_data</span>
              <span class="na">name</span><span class="pi">:</span> <span class="s">data</span>
      <span class="na">volumes</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">data</span>
          <span class="na">emptyDir</span><span class="pi">:</span> <span class="pi">{}</span>
</code></pre></div></div>

<p><a href="https://raw.githubusercontent.com/kubernetes/examples/master/cassandra-daemonset.yaml">下载示例</a></p>

<p>这个 DaemonSet 绝大部分的定义和上面的 ReplicationController 完全相同；它只是简单的给 daemon set 一个创建新的 Cassandra pods 的方法，并且以集群中所有的 Cassandra 节点为目标。</p>

<p>不同之处在于 <code class="highlighter-rouge">nodeSelector</code> 属性，它允许 DaemonSet 以全部节点的一个子集为目标（你可以向其他资源一样标记节点），并且没有 <code class="highlighter-rouge">replicas</code> 属性，因为它使用1对1的 node-pod 关系。</p>

<p>创建这个 DaemonSet：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">
</span><span class="gp">$</span> kubectl create <span class="nt">-f</span> cassandra/cassandra-daemonset.yaml
<span class="go">
</span></code></pre></div></div>

<p>你可能需要禁用配置文件检查，像这样：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">
</span><span class="gp">$</span> kubectl create <span class="nt">-f</span> cassandra/cassandra-daemonset.yaml <span class="nt">--validate</span><span class="o">=</span><span class="nb">false</span>
<span class="go">
</span></code></pre></div></div>

<p>你可以看到 DaemonSet 已经在运行：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">
</span><span class="gp">$</span> kubectl get daemonset
<span class="go">NAME        DESIRED   CURRENT   NODE-SELECTOR
</span><span class="gp">cassandra   3         3         &lt;none&gt;</span>
<span class="go">
</span></code></pre></div></div>

<p>现在，如果你列出集群中的 pods，并且使用 <code class="highlighter-rouge">app=cassandra</code> 标签过滤，你应该能够看到你的网络中的每一个节点上都有一个（且只有一个）新的 cassandra pod。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">
</span><span class="gp">$</span> kubectl get pods <span class="nt">-l</span><span class="o">=</span><span class="s2">"app=cassandra"</span> <span class="nt">-o</span> wide
<span class="go">NAME              READY     STATUS    RESTARTS   AGE       NODE
cassandra-ico4r   1/1       Running   0          4s        kubernetes-minion-rpo1
cassandra-kitfh   1/1       Running   0          1s        kubernetes-minion-9ye5
cassandra-tzw89   1/1       Running   0          2s        kubernetes-minion-b286

</span></code></pre></div></div>

<p>为了证明这是按设想的在工作，你可以再次使用 <code class="highlighter-rouge">nodetool</code> 命令来检查集群的状态。为此，请使用 <code class="highlighter-rouge">kubectl exec</code> 命令在任何一个新建的 cassandra pods 上运行 <code class="highlighter-rouge">nodetool</code>。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">
</span><span class="gp">$</span> kubectl <span class="nb">exec</span> <span class="nt">-ti</span> cassandra-xxxxx <span class="nt">--</span> nodetool status
<span class="go">Datacenter: datacenter1
=======================
Status=Up/Down
|/ State=Normal/Leaving/Joining/Moving
--  Address     Load       Tokens  Owns (effective)  Host ID                               Rack
UN  10.244.0.5  74.09 KB   256     100.0%            86feda0f-f070-4a5b-bda1-2eeb0ad08b77  rack1
UN  10.244.4.2  32.45 KB   256     100.0%            0b1be71a-6ffb-4895-ac3e-b9791299c141  rack1
UN  10.244.3.3  51.28 KB   256     100.0%            dafe3154-1d67-42e1-ac1d-78e7e80dce2b  rack1

</span></code></pre></div></div>

<p><strong>注意</strong>：这个示例让你在创建 DaemonSet 前删除了 cassandra的Replication Controller。这是因为为了保持示例的简单，RC 和 DaemonSet 使用了相同的 <code class="highlighter-rouge">app=cassandra</code> 标签（如此它们的 pods 映射到了我们创建的 service，这样 SeedProvider 就能识别它们）。</p>

<p>如果我们没有预先删除 RC，这两个资源在需要运行多少 pods 上将会发生冲突。如果希望的话，我们可以使用额外的标签和 selectors 来支持同时运行它们。</p>

<h2 id="步骤9资源清理">步骤9：资源清理</h2>

<p>当你准备删除你的资源时，按以下执行：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">
</span><span class="gp">$</span> kubectl delete service <span class="nt">-l</span> <span class="nv">app</span><span class="o">=</span>cassandra
<span class="gp">$</span> kubectl delete daemonset cassandra
<span class="go">
</span></code></pre></div></div>

<h3 id="自定义-seed-provider">自定义 Seed Provider</h3>

<p>我们使用了一个自定义的  <a href="https://svn.apache.org/repos/asf/cassandra/trunk/src/java/org/apache/cassandra/locator/SeedProvider.java"><code class="highlighter-rouge">SeedProvider</code></a> 来在 Kubernetes 之上运行 Cassandra。仅当你通过 replication control 或者 daemonset 部署 Cassandra 时才需要使用自定义的 seed provider。在 Cassandra 中，<code class="highlighter-rouge">SeedProvider</code> 引导 Cassandra 使用 gossip 协议来查找其它 Cassandra 节点。Seed 地址是被视为连接端点的主机。Cassandra 实例使用 seed 列表来查找彼此并学习 ring环拓扑。<a href="https://github.com/kubernetes/kubernetes/blob/master/examples/storage/cassandra/java/src/main/java/io/k8s/cassandra/KubernetesSeedProvider.java"><code class="highlighter-rouge">KubernetesSeedProvider</code></a> 通过 Kubernetes API 发现  Cassandra seeds IP 地址，那些 Cassandra 实例在 Cassandra Service 中定义。</p>

<p>请查阅自定义 seed provider 的 <a href="https://git.k8s.io/examples/cassandra/java/README.md">README</a> 文档，获取 <code class="highlighter-rouge">KubernetesSeedProvider</code> 进阶配置。对于本示例来说，你应该不需要自定义 Seed Provider 的配置。</p>

<p>查看本示例的 <a href="https://github.com/kubernetes/examples/tree/master/cassandra/image">image</a> 目录，了解如何构建容器的 docker 镜像及其内容。</p>

<p>你可能还注意到我们设置了一些 Cassandra 参数（<code class="highlighter-rouge">MAX_HEAP_SIZE</code>和<code class="highlighter-rouge">HEAP_NEWSIZE</code>），并且增加了关于 <a href="/docs/user-guide/namespaces">namespace</a> 的信息。我们还告诉 Kubernetes 容器暴露了 <code class="highlighter-rouge">CQL</code> 和 <code class="highlighter-rouge">Thrift</code> API 端口。最后，我们告诉集群管理器我们需要 0.1 cpu（0.1 核）。</p>

<p><a href="https://kubernetes-site.appspot.com/UA-36037335-10/GitHub/cassandra/README.md?pixel">!Analytics</a>]()</p>

