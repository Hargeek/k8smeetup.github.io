
<p>Kubernetes 集群中运行的应用通过抽象的 Service 查找彼此，相互通信和连接外部世界。本文揭示了发送到不同类型 Services 的数据包源 IP 的内幕，你可以根据需求改变这个行为。</p>

<ul id="markdown-toc">
  <li><a href="#objectives" id="markdown-toc-objectives">Objectives</a></li>
  <li><a href="#before-you-begin" id="markdown-toc-before-you-begin">Before you begin</a></li>
  <li><a href="#术语表" id="markdown-toc-术语表">术语表</a></li>
  <li><a href="#准备工作" id="markdown-toc-准备工作">准备工作</a></li>
  <li><a href="#typeclusterip-类型-services-的-source-ip" id="markdown-toc-typeclusterip-类型-services-的-source-ip">Type=ClusterIP 类型 Services 的 Source IP</a></li>
  <li><a href="#typenodeport-类型-services-的-source-ip" id="markdown-toc-typenodeport-类型-services-的-source-ip">Type=NodePort 类型 Services 的 Source IP</a></li>
  <li><a href="#typeloadbalancer-类型-services-的-source-ip" id="markdown-toc-typeloadbalancer-类型-services-的-source-ip">Type=LoadBalancer 类型 Services 的 Source IP</a></li>
  <li><a href="#cleaning-up" id="markdown-toc-cleaning-up">Cleaning up</a></li>
  <li><a href="#whats-next" id="markdown-toc-whats-next">What’s next</a></li>
</ul>

<h2 id="objectives">Objectives</h2>

<ul>
  <li>通过多种类型的 Services 暴露一个简单应用</li>
  <li>理解每种 Service 类型如何处理源 IP NAT</li>
  <li>理解保留源 IP 的折中</li>
</ul>

<h2 id="before-you-begin">Before you begin</h2>

<p>You need to have a Kubernetes cluster, and the kubectl command-line tool must
be configured to communicate with your cluster. If you do not already have a
cluster, you can create one by using
<a href="/docs/getting-started-guides/minikube">Minikube</a>,
or you can use one of these Kubernetes playgrounds:</p>

<ul>
  <li><a href="https://www.katacoda.com/courses/kubernetes/playground">Katacoda</a></li>
  <li><a href="http://labs.play-with-k8s.com/">Play with Kubernetes</a></li>
</ul>

<p>To check the version, enter <code class="highlighter-rouge">kubectl version</code>.</p>

<h2 id="术语表">术语表</h2>

<p>本文使用了下列术语：</p>

<ul>
  <li><a href="https://en.wikipedia.org/wiki/Network_address_translation">NAT</a>: 网络地址转换</li>
  <li><a href="https://en.wikipedia.org/wiki/Network_address_translation#SNAT">Source NAT</a>: 替换数据包的源 IP, 通常为节点的 IP</li>
  <li><a href="https://en.wikipedia.org/wiki/Network_address_translation#DNAT">Destination NAT</a>: 替换数据包的目的 IP, 通常为 Pod 的 IP</li>
  <li><a href="/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies">VIP</a>: 一个虚拟 IP, 例如分配给每个 Kubernetes Service 的 IP</li>
  <li><a href="/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies">Kube-proxy</a>: 一个网络守护程序，在每个节点上协调 Service VIP 管理</li>
</ul>

<h2 id="准备工作">准备工作</h2>

<p>你必须拥有一个正常工作的 Kubernetes 1.5 集群，用来运行本文中的示例。该示例使用一个简单的 nginx webserver 回送它接收到的请求的 HTTP 头中的源 IP 地址。你可以像下面这样创建它：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> kubectl run source-ip-app <span class="nt">--image</span><span class="o">=</span>gcr.io/google_containers/echoserver:1.4
<span class="go">deployment "source-ip-app" created
</span></code></pre></div></div>

<h2 id="typeclusterip-类型-services-的-source-ip">Type=ClusterIP 类型 Services 的 Source IP</h2>

<p>如果你的 kube-proxy 运行在 <a href="/docs/user-guide/services/#proxy-mode-iptables">iptables 模式</a>下，从集群内部发送到 ClusterIP 的包永远不会进行源地址 NAT，这从 Kubernetes 1.2 开始是默认选项。Kube-proxy 通过一个 <code class="highlighter-rouge">proxyMode</code> endpoint 暴露它的模式。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> kubectl get nodes
<span class="go">NAME                           STATUS     AGE     VERSION
kubernetes-minion-group-6jst   Ready      2h      v1.6.0+fff5156
kubernetes-minion-group-cx31   Ready      2h      v1.6.0+fff5156
kubernetes-minion-group-jj1t   Ready      2h      v1.6.0+fff5156

</span><span class="gp">kubernetes-minion-group-6jst $</span> curl localhost:10249/proxyMode
<span class="go">iptables
</span></code></pre></div></div>

<p>你可以通过在 source IP 应用上创建一个服务来测试源 IP 保留。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> kubectl expose deployment source-ip-app <span class="nt">--name</span><span class="o">=</span>clusterip <span class="nt">--port</span><span class="o">=</span>80 <span class="nt">--target-port</span><span class="o">=</span>8080
<span class="go">service "clusterip" exposed

</span><span class="gp">$</span> kubectl get svc clusterip
<span class="go">NAME         CLUSTER-IP    EXTERNAL-IP   PORT(S)   AGE
</span><span class="gp">clusterip    10.0.170.92   &lt;none&gt;</span>        80/TCP    51s
</code></pre></div></div>

<p>从相同集群中的一个 pod 访问这个 <code class="highlighter-rouge">ClusterIP</code>：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> kubectl run busybox <span class="nt">-it</span> <span class="nt">--image</span><span class="o">=</span>busybox <span class="nt">--restart</span><span class="o">=</span>Never <span class="nt">--rm</span>
<span class="go">Waiting for pod default/busybox to be running, status is Pending, pod ready: false
If you don't see a command prompt, try pressing enter.

</span><span class="gp">#</span> ip addr
<span class="gp">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt;</span> mtu 65536 qdisc noqueue
<span class="go">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
</span><span class="gp">3: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;</span> mtu 1460 qdisc noqueue
<span class="go">    link/ether 0a:58:0a:f4:03:08 brd ff:ff:ff:ff:ff:ff
    inet 10.244.3.8/24 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::188a:84ff:feb0:26a5/64 scope link
       valid_lft forever preferred_lft forever

</span><span class="gp">#</span> wget <span class="nt">-qO</span> - 10.0.170.92
<span class="go">CLIENT VALUES:
client_address=10.244.3.8
command=GET
</span><span class="c">...
</span></code></pre></div></div>

<p>如果客户端 pod 和 服务端 pod 在相同的节点上，client_address 就是客户端 pod 的 IP 地址。但是，如果它们在不同的节点上， client_address 将会是客户端 pod 所在节点的 flannel IP 地址。</p>

<h2 id="typenodeport-类型-services-的-source-ip">Type=NodePort 类型 Services 的 Source IP</h2>

<p>对于 Kubernetes 1.5，发送给类型为 <a href="/docs/user-guide/services/#type-nodeport">Type=NodePort</a> Services 的数据包默认进行源地址 NAT。你可以创建一个 <code class="highlighter-rouge">NodePort</code> Service 来进行测试：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> kubectl expose deployment source-ip-app <span class="nt">--name</span><span class="o">=</span>nodeport <span class="nt">--port</span><span class="o">=</span>80 <span class="nt">--target-port</span><span class="o">=</span>8080 <span class="nt">--type</span><span class="o">=</span>NodePort
<span class="go">service "nodeport" exposed

</span><span class="gp">$</span> <span class="nv">NODEPORT</span><span class="o">=</span><span class="k">$(</span>kubectl get <span class="nt">-o</span> <span class="nv">jsonpath</span><span class="o">=</span><span class="s2">"{.spec.ports[0].nodePort}"</span> services nodeport<span class="k">)</span>
<span class="gp">$</span> <span class="nv">NODES</span><span class="o">=</span><span class="k">$(</span>kubectl get nodes <span class="nt">-o</span> <span class="nv">jsonpath</span><span class="o">=</span><span class="s1">'{ $.items[*].status.addresses[?(@.type=="ExternalIP")].address }'</span><span class="k">)</span>
</code></pre></div></div>

<p>如果你的集群运行在一个云服务上，你可能需要为上面报告的 <code class="highlighter-rouge">nodes:nodeport</code> 开启一条防火墙规则。
现在，你可以通过上面分配的节点端口从外部访问这个 Service。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> <span class="k">for </span>node <span class="k">in</span> <span class="nv">$NODES</span><span class="p">;</span> <span class="k">do </span>curl <span class="nt">-s</span> <span class="nv">$node</span>:<span class="nv">$NODEPORT</span> | <span class="nb">grep</span> <span class="nt">-i</span> client_address<span class="p">;</span> <span class="k">done</span>
<span class="go">client_address=10.180.1.1
client_address=10.240.0.5
client_address=10.240.0.3
</span></code></pre></div></div>

<p>请注意，这些并不是正确的客户端 IP，它们是集群的内部 IP。这是所发生的事情：</p>

<ul>
  <li>客户端发送数据包到 <code class="highlighter-rouge">node2:nodePort</code></li>
  <li><code class="highlighter-rouge">node2</code> 使用它自己的 IP 地址替换数据包的源 IP 地址（SNAT）</li>
  <li><code class="highlighter-rouge">node2</code> 使用 pod IP 地址替换数据包的目的 IP 地址</li>
  <li>数据包被路由到 node 1，然后交给 endpoint</li>
  <li>Pod 的回复被路由回 node2</li>
  <li>Pod 的回复被发送回给客户端</li>
</ul>

<p>形象的：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>          client
             \ ^
              \ \
               v \
   node 1 &lt;--- node 2
    | ^   SNAT
    | |   ---&gt;
    v |
 endpoint
</code></pre></div></div>

<p>为了防止这种情况发生，Kubernetes 提供了一个特性来保留客户端的源 IP 地址<a href="/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip">(点击此处查看可用特性)</a>。设置 <code class="highlighter-rouge">service.spec.externalTrafficPolicy</code> 的值为 <code class="highlighter-rouge">Local</code>，请求就只会被代理到本地 endpoints 而不会被转发到其它节点。这样就保留了最初的源 IP 地址。如果没有本地 endpoints，发送到这个节点的数据包将会被丢弃。这样在应用到数据包的任何包处理规则下，你都能依赖这个正确的 source-ip 使数据包通过并到达 endpoint。</p>

<p>设置 <code class="highlighter-rouge">service.spec.externalTrafficPolicy</code> 字段如下：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> kubectl patch svc nodeport <span class="nt">-p</span> <span class="s1">'{"spec":{"externalTrafficPolicy":"Local"}}'</span>
<span class="go">service "nodeport" patched
</span></code></pre></div></div>

<p>现在，重新运行测试：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> <span class="k">for </span>node <span class="k">in</span> <span class="nv">$NODES</span><span class="p">;</span> <span class="k">do </span>curl <span class="nt">--connect-timeout</span> 1 <span class="nt">-s</span> <span class="nv">$node</span>:<span class="nv">$NODEPORT</span> | <span class="nb">grep</span> <span class="nt">-i</span> client_address<span class="p">;</span> <span class="k">done</span>
<span class="go">client_address=104.132.1.79
</span></code></pre></div></div>

<p>请注意，你只从 endpoint pod 运行的那个节点得到了一个回复，这个回复有<em>正确的</em>客户端 IP。</p>

<p>这是发生的事情：</p>

<ul>
  <li>客户端发送数据包到 <code class="highlighter-rouge">node2:nodePort</code>，它没有任何 endpoints</li>
  <li>数据包被丢弃</li>
  <li>客户端发送数据包到 <code class="highlighter-rouge">node1:nodePort</code>，它<em>有</em>endpoints</li>
  <li>node1 使用正确的源 IP 地址将数据包路由到 endpoint</li>
</ul>

<p>形象的：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        client
       ^ /   \
      / /     \
     / v       X
   node 1     node 2
    ^ |
    | |
    | v
 endpoint
</code></pre></div></div>

<h2 id="typeloadbalancer-类型-services-的-source-ip">Type=LoadBalancer 类型 Services 的 Source IP</h2>

<p>对于 Kubernetes 1.5，发送给类型为 <a href="/docs/user-guide/services/#type-nodeport">Type=LoadBalancer</a> Services 的数据包默认进行源地址 NAT，这是由于所有处于 <code class="highlighter-rouge">Ready</code> 状态的 Kubernetes 节点对于负载均衡的流量都是符合条件的。所以如果数据包到达一个没有 endpoint 的节点，系统将把这个包代理到<em>有</em> endpoint 的节点，并替换数据包的源 IP 为节点的 IP（如前面章节所述）。</p>

<p>你可以通过在一个 loadbalancer 上暴露这个 source-ip-app 来进行测试。</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> kubectl expose deployment source-ip-app <span class="nt">--name</span><span class="o">=</span>loadbalancer <span class="nt">--port</span><span class="o">=</span>80 <span class="nt">--target-port</span><span class="o">=</span>8080 <span class="nt">--type</span><span class="o">=</span>LoadBalancer
<span class="go">service "loadbalancer" exposed

</span><span class="gp">$</span> kubectl get svc loadbalancer
<span class="go">NAME           CLUSTER-IP    EXTERNAL-IP       PORT(S)   AGE
loadbalancer   10.0.65.118   104.198.149.140   80/TCP    5m

</span><span class="gp">$</span> curl 104.198.149.140
<span class="go">CLIENT VALUES:
client_address=10.240.0.5
</span><span class="c">...
</span></code></pre></div></div>

<p>然而，如果你的集群运行在 Google Kubernetes Engine/GCE 上，设置 <code class="highlighter-rouge">service.spec.externalTrafficPolicy</code> 字段值为 <code class="highlighter-rouge">Local</code> 可以强制使<em>没有</em> endpoints 的节点把他们自己从负载均衡流量的可选节点名单中删除。这是通过故意使它们健康检查失败达到的。</p>

<p>形象的：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                      client
                        |
                      lb VIP
                     / ^
                    v /
health check ---&gt;   node 1   node 2 &lt;--- health check
        200  &lt;---   ^ |             ---&gt; 500
                    | V
                 endpoint
</code></pre></div></div>

<p>你可以设置 annotation 来进行测试：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> kubectl patch svc loadbalancer <span class="nt">-p</span> <span class="s1">'{"spec":{"externalTrafficPolicy":"Local"}}'</span>
</code></pre></div></div>

<p>你应该能够立即看到 Kubernetes 分配的 <code class="highlighter-rouge">service.spec.healthCheckNodePort</code> 字段：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> kubectl get svc loadbalancer <span class="nt">-o</span> yaml | <span class="nb">grep</span> <span class="nt">-i</span> healthCheckNodePort
<span class="go">  healthCheckNodePort: 32122
</span></code></pre></div></div>

<p><code class="highlighter-rouge">service.spec.healthCheckNodePort</code> 字段指向每个节点在 <code class="highlighter-rouge">/healthz</code> 路径上提供的用于健康检查的端口。你可以这样测试：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ kubectl get pod -o wide -l run=source-ip-app
NAME                            READY     STATUS    RESTARTS   AGE       IP             NODE
source-ip-app-826191075-qehz4   1/1       Running   0          20h       10.180.1.136   kubernetes-minion-group-6jst

kubernetes-minion-group-6jst $ curl localhost:32122/healthz
1 Service Endpoints found

kubernetes-minion-group-jj1t $ curl localhost:32122/healthz
No Service Endpoints Found
</code></pre></div></div>

<p>主节点运行的 service 控制器负责分配 cloud loadbalancer。在这样做的同时，它也会分配指向每个节点的 HTTP 健康检查的 port/path。等待大约 10 秒钟之后，没有 endpoints 的两个节点的健康检查会失败，然后 curl 负载均衡器的 ip：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> curl 104.198.149.140
<span class="go">CLIENT VALUES:
client_address=104.132.1.79
</span><span class="c">...
</span></code></pre></div></div>

<p><strong>跨平台支持</strong></p>

<p>由于 Kubernetes 1.5 在类型为 Type=LoadBalancer 的 Services 中支持源 IP 保存的特性仅在 cloudproviders 的子集中实现（GCP and Azure）。你的集群运行的 cloudprovider 可能以某些不同的方式满足 loadbalancer 的要求：</p>

<ol>
  <li>
    <p>使用一个代理终止客户端连接并打开一个到你的 nodes/endpoints 的新连接。在这种情况下，源 IP 地址将永远是云负载均衡器的地址而不是客户端的。</p>
  </li>
  <li>
    <p>使用一个包转发器，因此从客户端发送到负载均衡器 VIP 的请求在拥有客户端源 IP 地址的节点终止，而不被中间代理。</p>
  </li>
</ol>

<p>第一类负载均衡器必须使用一种它和后端之间约定的协议来和真实的客户端 IP 通信，例如 HTTP <a href="https://en.wikipedia.org/wiki/X-Forwarded-For">X-FORWARDED-FOR</a> 头，或者 <a href="http://www.haproxy.org/download/1.5/doc/proxy-protocol.txt">proxy 协议</a>。
第二类负载均衡器可以通过简单的在保存于 Service 的 <code class="highlighter-rouge">service.spec.healthCheckNodePort</code> 字段上创建一个 HTTP 健康检查点来使用上面描述的特性。</p>

<h2 id="cleaning-up">Cleaning up</h2>

<p>删除服务：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> kubectl delete svc <span class="nt">-l</span> <span class="nv">run</span><span class="o">=</span>source-ip-app
</code></pre></div></div>

<p>删除 Deployment、ReplicaSet 和 Pod：</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> kubectl delete deployment source-ip-app
</code></pre></div></div>

<h2 id="whats-next">What’s next</h2>

<ul>
  <li>学习更多关于 <a href="/docs/concepts/services-networking/connect-applications-service/">通过 services 连接应用</a></li>
  <li>学习更多关于 <a href="/docs/user-guide/load-balancer">负载均衡</a></li>
</ul>

