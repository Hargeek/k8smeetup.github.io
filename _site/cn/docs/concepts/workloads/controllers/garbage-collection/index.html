
<p>Kubernetes 垃圾收集器的角色是删除指定的对象，这些对象曾经有但以后不再拥有 Owner 了。</p>

<p><strong>注意</strong>：垃圾收集是 beta 特性，在 Kubernetes 1.4 及以上版本默认启用。</p>

<ul id="markdown-toc">
  <li><a href="#owner-和-dependent" id="markdown-toc-owner-和-dependent">Owner 和 Dependent</a></li>
  <li><a href="#控制垃圾收集器删除-dependent" id="markdown-toc-控制垃圾收集器删除-dependent">控制垃圾收集器删除 Dependent</a>    <ul>
      <li><a href="#background-级联删除" id="markdown-toc-background-级联删除">Background 级联删除</a></li>
      <li><a href="#foreground-级联删除" id="markdown-toc-foreground-级联删除">Foreground 级联删除</a></li>
      <li><a href="#设置级联删除策略" id="markdown-toc-设置级联删除策略">设置级联删除策略</a></li>
    </ul>
  </li>
  <li><a href="#已知的问题" id="markdown-toc-已知的问题">已知的问题</a></li>
  <li><a href="#whats-next" id="markdown-toc-whats-next">What’s next</a></li>
</ul>

<h2 id="owner-和-dependent">Owner 和 Dependent</h2>

<p>某些 Kubernetes 对象是其它一些对象的 Owner。例如，一个 ReplicaSet 是一组 Pod 的 Owner。
具有 Owner 的对象被称为是 Owner 的 <em>Dependent</em>。
每个 Dependent 对象具有一个指向其所属对象的 <code class="highlighter-rouge">metadata.ownerReferences</code> 字段。</p>

<p>有时，Kubernetes 会自动设置 <code class="highlighter-rouge">ownerReference</code> 的值。
例如，当创建一个 ReplicaSet 时，Kubernetes 自动设置 ReplicaSet 中每个 Pod 的 <code class="highlighter-rouge">ownerReference</code> 字段值。
在 1.6 版本，Kubernetes 会自动为某些对象设置 <code class="highlighter-rouge">ownerReference</code> 的值，这些对象是由 ReplicationController、ReplicaSet、StatefulSet、DaemonSet 和 Deployment 所创建或管理。</p>

<p>也可以通过手动设置 <code class="highlighter-rouge">ownerReference</code> 的值，来指定 Owner 和 Dependent 之间的关系。</p>

<p>这里有一个配置文件，表示一个具有 3 个 Pod 的 ReplicaSet：</p>

<table class="includecode">
    <thead>
        <tr>
            <th>
                <a href="https://raw.githubusercontent.com/kubernetes/website/master/docs/concepts/workloads/controllers/my-repset.yaml" download="my-repset.yaml">
                    <code>my-repset.yaml</code>
                </a>
                <img src="/images/copycode.svg" style="max-height:24px" onclick="copyCode('my-repset.yaml')" title="Copy my-repset.yaml to clipboard" />
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
<div id="my-repset.yaml" class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">extensions/v1beta1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">ReplicaSet</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">my-repset</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">replicas</span><span class="pi">:</span> <span class="s">3</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">matchLabels</span><span class="pi">:</span>
      <span class="na">pod-is-for</span><span class="pi">:</span> <span class="s">garbage-collection-example</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">pod-is-for</span><span class="pi">:</span> <span class="s">garbage-collection-example</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">containers</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">nginx</span>
        <span class="na">image</span><span class="pi">:</span> <span class="s">nginx</span>
</code></pre></div></div>
</td>
        </tr>
    </tbody>
</table>

<p>如果创建该 ReplicaSet，然后查看 Pod 的 metadata 字段，能够看到 OwnerReferences 字段：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl create <span class="nt">-f</span> https://k8s.io/docs/concepts/controllers/my-repset.yaml
kubectl get pods <span class="nt">--output</span><span class="o">=</span>yaml
</code></pre></div></div>

<p>输出显示了 Pod 的 Owner 是名为 my-repset 的 ReplicaSet：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apiVersion: v1
kind: Pod
metadata:
  ...
  ownerReferences:
  - apiVersion: extensions/v1beta1
    controller: <span class="nb">true
    </span>blockOwnerDeletion: <span class="nb">true
    </span>kind: ReplicaSet
    name: my-repset
    uid: d9607e19-f88f-11e6-a518-42010a800195
  ...
</code></pre></div></div>

<h2 id="控制垃圾收集器删除-dependent">控制垃圾收集器删除 Dependent</h2>

<p>当删除对象时，可以指定是否该对象的 Dependent 也自动删除掉。
自动删除 Dependent 也称为 <em>级联删除</em>。
Kubernetes 中有两种 <em>级联删除</em> 的模式：<em>background</em> 模式和 <em>foreground</em> 模式。</p>

<p>如果删除对象时，不自动删除它的 Dependent，这些 Dependent 被称作是原对象的 <em>孤儿</em>。</p>

<h3 id="background-级联删除">Background 级联删除</h3>

<p>在 <em>background 级联删除</em> 模式下，Kubernetes 会立即删除 Owner 对象，然后垃圾收集器会在后台删除这些 Dependent。</p>

<h3 id="foreground-级联删除">Foreground 级联删除</h3>

<p>在 <em>foreground 级联删除</em> 模式下，根对象首先进入 “删除中” 状态。在 “删除中” 状态会有如下的情况：</p>

<ul>
  <li>对象仍然可以通过 REST API 可见。</li>
  <li>会设置对象的 <code class="highlighter-rouge">deletionTimestamp</code> 字段。</li>
  <li>对象的 <code class="highlighter-rouge">metadata.finalizers</code> 字段包含了值 “foregroundDeletion”。</li>
</ul>

<p>一旦对象被设置为 “删除中” 状态，垃圾收集器会删除对象的所有 Dependent。
 垃圾收集器在删除了所有 “Blocking” 状态的 Dependent（对象的 <code class="highlighter-rouge">ownerReference.blockOwnerDeletion=true</code>）之后，它会删除 Owner 对象。</p>

<p>注意，在 “foreground 删除” 模式下，只有设置了 <code class="highlighter-rouge">ownerReference.blockOwnerDeletion</code> 值得 Dependent 才能阻止删除 Owner 对象。
在 Kubernetes 1.7 版本中将增加许可控制器（Admission Controller），基于 Owner 对象上的删除权限来控制用户去设置 <code class="highlighter-rouge">blockOwnerDeletion</code> 的值为 true，所以未授权的 Dependent 不能够延迟 Owner 对象的删除。</p>

<p>如果一个对象的 <code class="highlighter-rouge">ownerReferences</code> 字段被一个 Controller（例如 Deployment 或 ReplicaSet）设置，<code class="highlighter-rouge">blockOwnerDeletion</code> 会被自动设置，不需要手动修改这个字段。</p>

<h3 id="设置级联删除策略">设置级联删除策略</h3>

<p>通过为 Owner 对象设置 <code class="highlighter-rouge">deleteOptions.propagationPolicy</code> 字段，可以控制级联删除策略。
可能的取值包括：“orphan”、“Foreground” 或 “Background”。</p>

<p>对很多 Controller 资源，包括 ReplicationController、ReplicaSet、StatefulSet、DaemonSet 和 Deployment，默认的垃圾收集策略是 <code class="highlighter-rouge">orphan</code>。
因此，除非指定其它的垃圾收集策略，否则所有 Dependent 对象使用的都是 <code class="highlighter-rouge">orphan</code> 策略。</p>

<p>下面是一个在后台删除 Dependent 对象的例子：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl proxy <span class="nt">--port</span><span class="o">=</span>8080
curl <span class="nt">-X</span> DELETE localhost:8080/apis/extensions/v1beta1/namespaces/default/replicasets/my-repset <span class="se">\</span>
<span class="nt">-d</span> <span class="s1">'{"kind":"DeleteOptions","apiVersion":"v1","propagationPolicy":"Background"}'</span> <span class="se">\</span>
<span class="nt">-H</span> <span class="s2">"Content-Type: application/json"</span>
</code></pre></div></div>

<p>下面是一个在前台删除 Dependent 对象的例子：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl proxy <span class="nt">--port</span><span class="o">=</span>8080
curl <span class="nt">-X</span> DELETE localhost:8080/apis/extensions/v1beta1/namespaces/default/replicasets/my-repset <span class="se">\</span>
<span class="nt">-d</span> <span class="s1">'{"kind":"DeleteOptions","apiVersion":"v1","propagationPolicy":"Foreground"}'</span> <span class="se">\</span>
<span class="nt">-H</span> <span class="s2">"Content-Type: application/json"</span>
</code></pre></div></div>

<p>下面是一个孤儿 Dependent 的例子：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl proxy <span class="nt">--port</span><span class="o">=</span>8080
curl <span class="nt">-X</span> DELETE localhost:8080/apis/extensions/v1beta1/namespaces/default/replicasets/my-repset <span class="se">\</span>
<span class="nt">-d</span> <span class="s1">'{"kind":"DeleteOptions","apiVersion":"v1","propagationPolicy":"Orphan"}'</span> <span class="se">\</span>
<span class="nt">-H</span> <span class="s2">"Content-Type: application/json"</span>
</code></pre></div></div>

<p>kubectl 也支持级联删除。
通过设置 <code class="highlighter-rouge">--cascade</code> 为 true，可以使用 kubectl 自动删除 Dependent 对象。
设置 <code class="highlighter-rouge">--cascade</code> 为 false，会使 Dependent 对象成为孤儿 Dependent 对象。
<code class="highlighter-rouge">--cascade</code> 的默认值是 true。</p>

<p>下面是一个例子，使一个 ReplicaSet 的 Dependent 对象成为孤儿 Dependent：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl delete replicaset my-repset <span class="nt">--cascade</span><span class="o">=</span><span class="nb">false</span>
</code></pre></div></div>

<h2 id="已知的问题">已知的问题</h2>
<ul>
  <li>1.7 版本，垃圾收集不支持 <a href="/docs/concepts/api-extension/custom-resources/">自定义资源</a>，比如那些通过 CustomResourceDefinition 新增，或者通过 API server 聚集而成的资源对象。</li>
</ul>

<p><a href="https://github.com/kubernetes/kubernetes/issues/26120">其它已知的问题</a></p>

<h2 id="whats-next">What’s next</h2>

<p><a href="https://git.k8s.io/community/contributors/design-proposals/garbage-collection.md">设计文档 1</a>
<a href="https://git.k8s.io/community/contributors/design-proposals/synchronous-garbage-collection.md">设计文档 2</a></p>

