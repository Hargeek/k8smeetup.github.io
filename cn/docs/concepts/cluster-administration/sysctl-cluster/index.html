<ul id="markdown-toc">
  <li><a href="#什么是sysctl" id="markdown-toc-什么是sysctl">什么是Sysctl？</a></li>
  <li><a href="#命名空间级vs节点级sysctls" id="markdown-toc-命名空间级vs节点级sysctls">命名空间级vs.节点级Sysctls</a></li>
  <li><a href="#安全的-vs-不安全的-sysctls" id="markdown-toc-安全的-vs-不安全的-sysctls">安全的 vs. 不安全的 Sysctls</a></li>
  <li><a href="#使能不安全的sysctls" id="markdown-toc-使能不安全的sysctls">使能不安全的Sysctls</a></li>
  <li><a href="#给pod配置sysctls" id="markdown-toc-给pod配置sysctls">给Pod配置Sysctls</a></li>
</ul>

<p>这篇文章描述了如何在Kubernetes集群中使用Sysctls。</p>

<h2 id="什么是sysctl">什么是Sysctl？</h2>

<p>在Linux中，Sysctl接口允许管理员在内核运行时修改内核参数。这些可用参数都存在于虚拟进程文件系统中的<code class="highlighter-rouge">/proc/sys/</code>目录。这些内核参数作用于各种子系统中，例如：</p>

<ul>
  <li>内核 (通用前缀：<code class="highlighter-rouge">kernel.</code>)</li>
  <li>网络 (通用前缀：<code class="highlighter-rouge">net.</code>)</li>
  <li>虚拟内存 (通用前缀：<code class="highlighter-rouge">vm.</code>)</li>
  <li>设备专用 (通用前缀：<code class="highlighter-rouge">dev.</code>)</li>
  <li>更多子系统描述见 <a href="https://www.kernel.org/doc/Documentation/sysctl/README">Kernel docs</a>.</li>
</ul>

<p>获取所有参数列表，可运行</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ sudo sysctl -a
</code></pre></div></div>

<h2 id="命名空间级vs节点级sysctls">命名空间级vs.节点级Sysctls</h2>

<p>在今天的Linux内核系统中有一些Sysctls是 <em>命名空间级</em> 的。这意味着他们在同节点的不同pod间是可配置成独立的。在kubernetes里，命名空间级是Sysctls的一个必要条件，以使其在一个pod语境里易于理解。</p>

<p>以下列出了Sysctls中已知的 <em>命名空间级</em> ：</p>

<ul>
  <li><code class="highlighter-rouge">kernel.shm*</code>（内核中共享内存相关参数），</li>
  <li><code class="highlighter-rouge">kernel.msg*</code>（内核中SystemV消息队列相关参数），</li>
  <li><code class="highlighter-rouge">kernel.sem</code>（内核中信号量参数），</li>
  <li><code class="highlighter-rouge">fs.mqueue.*</code>（内核中POSIX消息队列相关参数），</li>
  <li><code class="highlighter-rouge">net.*</code>（内核中网络配置项相关参数）。</li>
</ul>

<p>Sysctls中非命名空间级的被称为 <em>节点级</em> ，其必须由集群管理员手动设置，要么通过节点的底层Linux分布方式(例如，通过 <code class="highlighter-rouge">/etc/sysctls.conf</code>)，亦或在特权容器中使用Daemonset。</p>

<p><strong>注意</strong>: 这是很好的做法，考虑在一个集群里给有特殊sysctl的节点设置为 <em>污点</em> ，并且给他们安排仅需要这些sysctl设置的pods。 建议采用Kubernetes <a href="/docs/user-guide/kubectl/v1.8/#taint"><em>污点和容点</em>
特征</a> 来实现。</p>

<h2 id="安全的-vs-不安全的-sysctls">安全的 vs. 不安全的 Sysctls</h2>

<p>Sysctls被分为 <em>安全的</em> 和 <em>不安全的</em> sysctls。同一节点上的pods间除了适当命名空间命名一个 <em>安全的</em> sysctl，还必须适当的 <em>隔离</em> 。 这意味着给一个pod设置一个 <em>安全的</em> sysctl</p>

<ul>
  <li>不能对相同节点上其他pod产生任何影响</li>
  <li>不能对节点的健康造成损害</li>
  <li>不能在pod资源限制以外获取更多的CPU和内存资源</li>
</ul>

<p>目前看来，大多数的 <em>命名空间级</em> sysctls 不一定被认为是 <em>安全的</em> 。</p>

<p>在Kubernetes 1.4版本中，以下sysctls提供了 <em>安全的</em> 配置：</p>

<ul>
  <li><code class="highlighter-rouge">kernel.shm_rmid_forced</code>,</li>
  <li><code class="highlighter-rouge">net.ipv4.ip_local_port_range</code>,</li>
  <li><code class="highlighter-rouge">net.ipv4.tcp_syncookies</code>.</li>
</ul>

<p>该列表在未来的Kubernetes版本里还会继续扩充，当kubelet提供更好的隔离机制时。</p>

<p>所有 <em>安全的</em> sysctls 都是默认启用的。</p>

<p>所有 <em>不安全的</em> sysctls 默认是关闭的，且必须通过每个节点基础上的集群管理手动开启。禁用不安全的sysctls的Pods将会被计划，但不会启动。</p>

<p><strong>警告</strong>: 由于他们的本质是 <em>不安全的</em> ，使用 <em>不安全的</em> sysctls是自担风险的，并且会导致严重的问题，例如容器的错误行为，资源短缺或者是一个节点的完全破损。</p>

<h2 id="使能不安全的sysctls">使能不安全的Sysctls</h2>

<p>牢记上面的警告， 在非常特殊的情况下，例如高性能指标或是实时应用程序优化，集群管理员可以允许 <em>不安全的</em>
sysctls。 <em>不安全的</em> sysctls 会打上kubelet标识，在逐节点的基础上被启用，例如：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubelet <span class="nt">--experimental-allowed-unsafe-sysctls</span> <span class="s1">'kernel.msg*,net.ipv4.route.min_pmtu'</span> ...
</code></pre></div></div>

<p>只有 <em>命名空间级</em> sysctls 可以使用该方法启用。</p>

<h2 id="给pod配置sysctls">给Pod配置Sysctls</h2>

<p>在Kubernetes 1.4版本中，sysctl特性是一个alpha API。因此，sysctls被设置为在pods上使用注释。它们适用于同一个pod上的所有容器。</p>

<p>这里列举了一个例子， <em>安全的</em> 和 <em>不安全的</em> sysctls使用不同的注释:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">sysctl-example</span>
  <span class="na">annotations</span><span class="pi">:</span>
    <span class="s">security.alpha.kubernetes.io/sysctls</span><span class="pi">:</span> <span class="s">kernel.shm_rmid_forced=1</span>
    <span class="s">security.alpha.kubernetes.io/unsafe-sysctls</span><span class="pi">:</span> <span class="s">net.ipv4.route.min_pmtu=1000,kernel.msgmax=1 2 3</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="s">...</span>
</code></pre></div></div>

<p><strong>注意</strong>: 包含以上规定的 <em>不安全的</em> sysctls的一个Pod， 将无法启动任何不能使这两个 <em>不安全的</em> sysctls明确的节点。 推荐
<em>节点级</em> sysctls使用 <a href="/docs/user-guide/kubectl/v1.6/#taint"><em>容点和污点</em>
特征</a> or <a href="/docs/concepts/configuration/taint-and-toleration/">taints on nodes</a>
来将这些pods分配到正确的nodes上。</p>
