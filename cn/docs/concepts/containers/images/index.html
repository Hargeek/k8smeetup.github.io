
<p>在Kubernetes pod中引用镜像前，请创建Docker镜像，并将之推送到镜像仓库中。
容器的“image”属性支持和Docker命令行相同的语法，包括私有仓库和标签。</p>

<ul id="markdown-toc">
  <li><a href="#升级镜像" id="markdown-toc-升级镜像">升级镜像</a></li>
  <li><a href="#使用私有仓库" id="markdown-toc-使用私有仓库">使用私有仓库</a>    <ul>
      <li><a href="#使用-google-container-registry" id="markdown-toc-使用-google-container-registry">使用 Google Container Registry</a></li>
      <li><a href="#使用-aws-ec2-container-registry" id="markdown-toc-使用-aws-ec2-container-registry">使用 AWS EC2 Container Registry</a></li>
      <li><a href="#使用-azure-container-registry-acr" id="markdown-toc-使用-azure-container-registry-acr">使用 Azure Container Registry (ACR)</a></li>
      <li><a href="#配置nodes对私有仓库认证" id="markdown-toc-配置nodes对私有仓库认证">配置Nodes对私有仓库认证</a></li>
      <li><a href="#提前拉取镜像" id="markdown-toc-提前拉取镜像">提前拉取镜像</a></li>
      <li><a href="#在pod上指定imagepullsecrets" id="markdown-toc-在pod上指定imagepullsecrets">在pod上指定ImagePullSecrets</a>        <ul>
          <li><a href="#使用docker-config创建secret" id="markdown-toc-使用docker-config创建secret">使用Docker Config创建Secret</a></li>
          <li><a href="#通过kubectl创建secret" id="markdown-toc-通过kubectl创建secret">通过kubectl创建secret</a></li>
          <li><a href="#在pod中引用imagepullsecrets" id="markdown-toc-在pod中引用imagepullsecrets">在pod中引用imagePullSecrets</a></li>
        </ul>
      </li>
      <li><a href="#使用场景" id="markdown-toc-使用场景">使用场景</a></li>
    </ul>
  </li>
</ul>

<h2 id="升级镜像">升级镜像</h2>
<p>默认的镜像拉取策略是“IfNotPresent”，在镜像已经存在的情况下，kubelet将不在去拉取镜像。
如果总是想要拉取镜像，必须设置拉取策略为“Always”或者设置镜像标签为“:latest”。</p>

<p>如果没有指定镜像的标签，它会被假定为“:latest”,同时拉取策略为“Always”。</p>

<p>注意应避免使用“:latest”标签，参见 <a href="/docs/concepts/configuration/overview/#container-images">Best Practices for Configuration</a> 获取更多信息。</p>

<h2 id="使用私有仓库">使用私有仓库</h2>

<p>从私有仓库读取镜像时可能需要密钥。
凭证可以用以下方式提供:</p>

<ul>
  <li>使用Google Container Registry
    <ul>
      <li>每个集群分别配置</li>
      <li>在Google Compute Engine 或者 Google Kubernetes Engine上自动配置</li>
      <li>所有的pod都能读取项目的私有仓库</li>
    </ul>
  </li>
  <li>使用 AWS EC2 Container Registry (ECR)
    <ul>
      <li>使用IAM角色和策略来控制对ECR仓库的访问</li>
      <li>自动刷新ECR的登录凭证</li>
    </ul>
  </li>
  <li>使用 Azure Container Registry (ACR)</li>
  <li>配置节点对私有仓库认证
    <ul>
      <li>所有的pod都可以读取已配置的私有仓库</li>
      <li>需要集群管理员提供node的配置</li>
    </ul>
  </li>
  <li>提前拉取镜像
    <ul>
      <li>所有的pod都可以使用node上缓存的镜像</li>
      <li>需要以root进入node操作</li>
    </ul>
  </li>
  <li>pod上指定 ImagePullSecrets
    <ul>
      <li>只有提供了密钥的pod才能接入私有仓库
下面将详细描述每一项</li>
    </ul>
  </li>
</ul>

<h3 id="使用-google-container-registry">使用 Google Container Registry</h3>
<p>Kuberetes运行在Google Compute Engine (GCE)时原生支持[Google ContainerRegistry (GCR)]
(https://cloud.google.com/tools/container-registry/)。如果kubernetes集群运行在GCE
或者Google Kubernetes Engine 上，使用镜像全名(e.g. gcr.io/my_project/image:tag)即可。</p>

<p>集群中的所有pod都会有读取这个仓库中镜像的权限。</p>

<p>Kubelet将使用实例的Google service account向GCR认证。实例的service account拥有
<code class="highlighter-rouge">https://www.googleapis.com/auth/devstorage.read_only</code>，所以它可以从项目的GCR拉取，但不能推送。</p>

<h3 id="使用-aws-ec2-container-registry">使用 AWS EC2 Container Registry</h3>

<p>当Node是AWS EC2实例时，Kubernetes原生支持<a href="https://aws.amazon.com/ecr/">AWS EC2 ContainerRegistry</a>。</p>

<p>在pod定义中，使用镜像全名即可 (例如 <code class="highlighter-rouge">ACCOUNT.dkr.ecr.REGION.amazonaws.com/imagename:tag</code>)</p>

<p>集群中可以创建pod的用户都可以使用ECR中的任意镜像运行pod。</p>

<p>Kubelet会获取并且定期刷新ECR的凭证。它需要以下权限</p>

<ul>
  <li><code class="highlighter-rouge">ecr:GetAuthorizationToken</code></li>
  <li><code class="highlighter-rouge">ecr:BatchCheckLayerAvailability</code></li>
  <li><code class="highlighter-rouge">ecr:GetDownloadUrlForLayer</code></li>
  <li><code class="highlighter-rouge">ecr:GetRepositoryPolicy</code></li>
  <li><code class="highlighter-rouge">ecr:DescribeRepositories</code></li>
  <li><code class="highlighter-rouge">ecr:ListImages</code></li>
  <li><code class="highlighter-rouge">ecr:BatchGetImage</code></li>
</ul>

<p>要求：</p>

<ul>
  <li>必须使用kubelet 1.2.0及以上版本</li>
  <li>如果node在区域A，而镜像仓库在另一个区域B，需要1.3.0及以上版本</li>
  <li>区域中必须提供ECR</li>
</ul>

<p>诊断</p>

<ul>
  <li>验证是否满足以上要求</li>
  <li>获取工作站的$REGION (例如 <code class="highlighter-rouge">us-west-2</code>)凭证，使用凭证SSH到主机手动运行docker，检查是否运行</li>
  <li>验证kublet是否使用参数<code class="highlighter-rouge">--cloud-provider=aws</code>运行</li>
  <li>检查kubelet日志(例如 <code class="highlighter-rouge">journalctl -u kubelet</code>)，是否有类似的行
    <ul>
      <li><code class="highlighter-rouge">plugins.go:56] Registering credential provider: aws-ecr-key</code></li>
      <li><code class="highlighter-rouge">provider.go:91] Refreshing cache for provider: *aws_credentials.ecrProvider</code></li>
    </ul>
  </li>
</ul>

<h3 id="使用-azure-container-registry-acr">使用 Azure Container Registry (ACR)</h3>
<p>当使用<a href="https://azure.microsoft.com/en-us/services/container-registry/">Azure Container Registry</a>时，可以使用admin user或者service principal认证。
任何一种情况，认证都通过标准的Dokcer authentication完成。本指南假设使用<a href="https://github.com/azure/azure-cli">azure-cli</a>
命令行工具。</p>

<p>首先，需要创建仓库并获取凭证，完整的文档请参考
<a href="https://docs.microsoft.com/en-us/azure/container-registry/container-registry-get-started-azure-cli">Azure container registry documentation</a>。</p>

<p>创建好容器仓库后，可以使用以下凭证登录：</p>

<ul>
  <li><code class="highlighter-rouge">DOCKER_USER</code> : service principal, or admin username</li>
  <li><code class="highlighter-rouge">DOCKER_PASSWORD</code>: service principal password, or admin user password</li>
  <li><code class="highlighter-rouge">DOCKER_REGISTRY_SERVER</code>: <code class="highlighter-rouge">${some-registry-name}.azurecr.io</code></li>
  <li><code class="highlighter-rouge">DOCKER_EMAIL</code>: <code class="highlighter-rouge">${some-email-address}</code></li>
</ul>

<p>填写以上变量后，就可以
<a href="/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod">configure a Kubernetes Secret and use it to deploy a Pod</a>。</p>

<h3 id="配置nodes对私有仓库认证">配置Nodes对私有仓库认证</h3>

<p><strong>注意：</strong> 如果在Google Kubernetes Engine 上运行集群，每个节点上都会有<code class="highlighter-rouge">.dockercfg</code>文件，它包含对Google Container Registry的凭证。
不需要使用以下方法。</p>

<p><strong>注意：</strong> 如果在AWS EC2上运行集群且准备使用EC2 Container Registry (ECR)，每个node上的kubelet会管理和更新ECR的登录凭证。不需要使用以下方法。</p>

<p><strong>注意：</strong> 该方法适用于能够对节点进行配置的情况。该方法在GCE及在其它能自动配置节点的云平台上并不适合。</p>

<p>Docker将私有仓库的密钥存放在<code class="highlighter-rouge">$HOME/.dockercfg</code>或<code class="highlighter-rouge">$HOME/.docker/config.json</code>文件中。Kubelet上，docker会使用root用户<code class="highlighter-rouge">$HOME</code>路径下的密钥。</p>

<p>推荐如下步骤来为node配置私有仓库。以下示例在PC或笔记本电脑中操作</p>

<p>1.对于想要使用的每一种凭证，运行 <code class="highlighter-rouge">docker login [server]</code>，它会更新<code class="highlighter-rouge">$HOME/.docker/config.json</code>。
   1.使用编辑器查看<code class="highlighter-rouge">$HOME/.docker/config.json</code>，保证文件中包含了想要使用的凭证
   1.获取node列表，例如
     - 如果使用node名称，<code class="highlighter-rouge">nodes=$(kubectl get nodes -o jsonpath='{range.items[*].metadata}{.name} {end}')</code>
	 - 如果使用node IP ，<code class="highlighter-rouge">nodes=$(kubectl get nodes -o jsonpath='{range .items[*].status.addresses[?(@.type=="ExternalIP")]}{.address} {end}')</code>
   1.将本地的<code class="highlighter-rouge">.docker/config.json</code>拷贝到每个节点root用户目录下
     - 例如： <code class="highlighter-rouge">for n in $nodes; do scp ~/.docker/config.json root@$n:/root/.docker/config.json; done</code></p>

<p>创建使用私有仓库的pod来验证，例如：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">$ cat &lt;&lt;EOF &gt; /tmp/private-image-test-1.yaml</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">private-image-test-1</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">containers</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">uses-private-image</span>
      <span class="na">image</span><span class="pi">:</span> <span class="s">$PRIVATE_IMAGE_NAME</span>
      <span class="na">imagePullPolicy</span><span class="pi">:</span> <span class="s">Always</span>
      <span class="na">command</span><span class="pi">:</span> <span class="pi">[</span> <span class="s2">"</span><span class="s">echo"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">SUCCESS"</span> <span class="pi">]</span>
<span class="s">EOF</span>
<span class="s">$ kubectl create -f /tmp/private-image-test-1.yaml</span>
<span class="s">pod "private-image-test-1" created</span>
<span class="s">$</span>
</code></pre></div></div>

<p>如果一切正常，一段时间后，可以看到:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl logs private-image-test-1
SUCCESS
</code></pre></div></div>

<p>如果失败，则可以看到：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl describe pods/private-image-test-1 | <span class="nb">grep</span> <span class="s2">"Failed"</span>
  Fri, 26 Jun 2015 15:36:13 <span class="nt">-0700</span>    Fri, 26 Jun 2015 15:39:13 <span class="nt">-0700</span>    19    <span class="o">{</span>kubelet node-i2hq<span class="o">}</span>    spec.containers<span class="o">{</span>uses-private-image<span class="o">}</span>    failed        Failed to pull image <span class="s2">"user/privaterepo:v1"</span>: Error: image user/privaterepo:v1 not found
</code></pre></div></div>

<p>必须保证集群中所有的节点都有相同的<code class="highlighter-rouge">.docker/config.json</code>文件。否则,pod会在一些节点上正常运行而在另一些节点上无法启动
例如，如果使用node自动弹缩，那么每个实例模板都需要包含<code class="highlighter-rouge">.docker/config.json</code>，或者挂载一个包含这个文件的驱动器。</p>

<p>在<code class="highlighter-rouge">.docker/config.json</code>中配置了私有仓库密钥后，所有pod都会能读取私有仓库中的镜像。</p>

<p><strong>该方法已在6月26日的docker私有仓库和kubernetes v0.19.3上测试通过，其他私有仓库，如quay.io应该也可以运行，但未测试过。</strong></p>

<h3 id="提前拉取镜像">提前拉取镜像</h3>

<p><strong>注意：</strong> 如果在Google Kubernetes Engine 上运行集群，每个节点上都会有<code class="highlighter-rouge">.dockercfg</code>文件，它包含对Google Container Registry的凭证。
不需要使用以下方法。</p>

<p><strong>注意：</strong> 该方法适用于能够对节点进行配置的情况。该方法在GCE及在其它能自动配置节点的云平台上并不适合。</p>

<p>默认情况下，kubelet会尝试从指定的仓库拉取每一个镜像
但是，如果容器属性<code class="highlighter-rouge">imagePullPolicy</code>设置为<code class="highlighter-rouge">IfNotPresent</code>或者<code class="highlighter-rouge">Never</code>，
则会使用本地镜像（优先、唯一、分别）。</p>

<p>如果依赖提前拉取镜像代替仓库认证，
必须保证集群所有的节点提前拉取的镜像是相同的。</p>

<p>可以用于提前载入指定的镜像以提高速度，或者作为私有仓库认证的一种替代方案</p>

<p>所有的pod都可以使用node上缓存的镜像</p>

<h3 id="在pod上指定imagepullsecrets">在pod上指定ImagePullSecrets</h3>

<p><strong>注意:</strong> Google Kubernetes Engine,GCE及其他自动创建node的云平台上，推荐使用本方法。</p>

<p>Kuberentes支持在pod中指定仓库密钥。</p>

<h4 id="使用docker-config创建secret">使用Docker Config创建Secret</h4>

<p>运行以下命令，将大写字母代替为合适的值</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl create secret docker-registry myregistrykey <span class="nt">--docker-server</span><span class="o">=</span>DOCKER_REGISTRY_SERVER <span class="nt">--docker-username</span><span class="o">=</span>DOCKER_USER <span class="nt">--docker-password</span><span class="o">=</span>DOCKER_PASSWORD <span class="nt">--docker-email</span><span class="o">=</span>DOCKER_EMAIL
secret <span class="s2">"myregistrykey"</span> created.
</code></pre></div></div>

<p>如果需要接入多个仓库，可以为每个仓库创建一个secret。
当为pod拉取镜像时，kubelet会将<code class="highlighter-rouge">imagePullSecrets</code>合入一个独立虚拟的<code class="highlighter-rouge">.docker/config.json</code>。</p>

<p>Pod只能引用和它相同namespace的ImagePullSecrets，
所以需要为每一个namespace做配置</p>

<h4 id="通过kubectl创建secret">通过kubectl创建secret</h4>

<p>由于某种原因在一个<code class="highlighter-rouge">.docker/config.json</code>中需要多个项或者需要非上述命令给出的secret，可以<a href="/docs/user-guide/secrets/#creating-a-secret-manually">create a secret using
json or yaml</a>。</p>

<p>请保证：</p>

<ul>
  <li>设置data项的名称为<code class="highlighter-rouge">.dockerconfigjson</code></li>
  <li>使用base64对docker文件编码，并将字符准确黏贴到<code class="highlighter-rouge">data[".dockerconfigjson"]</code>里</li>
  <li>设置<code class="highlighter-rouge">type</code>为<code class="highlighter-rouge">kubernetes.io/dockerconfigjson</code></li>
</ul>

<p>示例：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Secret</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">myregistrykey</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">awesomeapps</span>
<span class="na">data</span><span class="pi">:</span>
  <span class="s">.dockerconfigjson</span><span class="pi">:</span> <span class="s">UmVhbGx5IHJlYWxseSByZWVlZWVlZWVlZWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGx5eXl5eXl5eXl5eXl5eXl5eXl5eSBsbGxsbGxsbGxsbGxsbG9vb29vb29vb29vb29vb29vb29vb29vb29vb25ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubmdnZ2dnZ2dnZ2dnZ2dnZ2dnZ2cgYXV0aCBrZXlzCg==</span>
<span class="na">type</span><span class="pi">:</span> <span class="s">kubernetes.io/dockerconfigjson</span>
</code></pre></div></div>

<p>如果收到错误消息<code class="highlighter-rouge">error: no objects passed to create</code>，可能是 base64 编码后的字符串非法。
如果收到错误消息类似<code class="highlighter-rouge">Secret "myregistrykey" is invalid: data[.dockerconfigjson]: invalid value ...</code>,
说明数据已经解码成功，但是不满足<code class="highlighter-rouge">.docker/config.json</code>文件的语法。</p>

<h4 id="在pod中引用imagepullsecrets">在pod中引用imagePullSecrets</h4>

<p>现在，在创建pod时，可以在pod定义中增加<code class="highlighter-rouge">imagePullSecrets</code>小节来引用secret</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">foo</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">awesomeapps</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">containers</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">foo</span>
      <span class="na">image</span><span class="pi">:</span> <span class="s">janedoe/awesomeapp:v1</span>
  <span class="na">imagePullSecrets</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">myregistrykey</span>
</code></pre></div></div>

<p>对每一个使用私有仓库的pod，都需要做以上操作。</p>

<p>也可以在<a href="/docs/user-guide/service-accounts">serviceAccount</a> 资源中设置imagePullSecrets自动设置<code class="highlighter-rouge">imagePullSecrets</code></p>

<p><code class="highlighter-rouge">imagePullSecrets</code>可以和每个node上的<code class="highlighter-rouge">.docker/config.json</code>一起使用，他们将共同生效。本方法在Google Kubernetes Engine
也能正常工作。</p>

<h3 id="使用场景">使用场景</h3>

<p>配置私有仓库有多种方案，以下是一些常用场景和建议的解决方案。</p>

<ol>
  <li>集群运行非专有（例如 开源镜像）镜像。镜像不需要隐藏。
    <ul>
      <li>使用Docker hub上的公有镜像</li>
      <li>无需配置</li>
      <li>在GCE/GKE上会自动使用高稳定性和高速的Docker hub的本地mirror</li>
    </ul>
  </li>
  <li>集群运行一些专有镜像，这些镜像对外部公司需要隐藏，对集群用户可见
    <ul>
      <li>使用自主的私有<a href="https://docs.docker.com/registry/">Docker registry</a>.
        <ul>
          <li>可以放置在<a href="https://hub.docker.com/account/signup/">Docker Hub</a>,或者其他地方。</li>
          <li>按照上面的描述，在每个节点手动配置.docker/config.json</li>
        </ul>
      </li>
      <li>或者，在防火墙内运行一个内置的私有仓库，并开放读取权限
        <ul>
          <li>不需要配置Kubenretes</li>
        </ul>
      </li>
      <li>或者，在GCE/GKE上时，使用项目的Google Container Registry
        <ul>
          <li>使用集群自动伸缩比手动配置node工作的更好</li>
        </ul>
      </li>
      <li>或者，在更改集群node配置不方便时，使用<code class="highlighter-rouge">imagePullSecrets</code></li>
    </ul>
  </li>
  <li>使用专有镜像的集群，有更严格的访问控制
    <ul>
      <li>保证<a href="/docs/admin/admission-controllers/#alwayspullimages">AlwaysPullImages admission controller</a>开启。否则，所有的pod都可以使用镜像</li>
      <li>将敏感数据存储在”Secret”资源中，而不是打包在镜像里</li>
    </ul>
  </li>
  <li>多租户集群下，每个租户需要自己的私有仓库
    <ul>
      <li>保证<a href="/docs/admin/admission-controllers/#alwayspullimages">AlwaysPullImages admission controller</a>开启。否则，所有租户的所有的pod都可以使用镜像</li>
      <li>私有仓库开启认证</li>
      <li>为每个租户获取仓库凭证，放置在secret中，并发布到每个租户的namespace下</li>
      <li>租户将secret增加到每个namespace下的imagePullSecrets中</li>
    </ul>
  </li>
</ol>

