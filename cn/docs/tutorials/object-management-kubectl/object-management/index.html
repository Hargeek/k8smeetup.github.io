
<p><code class="highlighter-rouge">kubectl</code> 命令行工具支持 Kubernetes 对象几种不同的创建和管理方法。本文档简要介绍了这些方法.</p>

<ul id="markdown-toc">
  <li><a href="#管理技巧" id="markdown-toc-管理技巧">管理技巧</a></li>
  <li><a href="#命令式的方式" id="markdown-toc-命令式的方式">命令式的方式</a>    <ul>
      <li><a href="#例子" id="markdown-toc-例子">例子</a></li>
      <li><a href="#权衡" id="markdown-toc-权衡">权衡</a></li>
    </ul>
  </li>
  <li><a href="#命令式对象配置" id="markdown-toc-命令式对象配置">命令式对象配置</a>    <ul>
      <li><a href="#例子-1" id="markdown-toc-例子-1">例子</a></li>
      <li><a href="#权衡-1" id="markdown-toc-权衡-1">权衡</a></li>
    </ul>
  </li>
  <li><a href="#声明式对象配置" id="markdown-toc-声明式对象配置">声明式对象配置</a>    <ul>
      <li><a href="#例子-2" id="markdown-toc-例子-2">例子</a></li>
      <li><a href="#权衡-2" id="markdown-toc-权衡-2">权衡</a></li>
    </ul>
  </li>
  <li><a href="#whats-next" id="markdown-toc-whats-next">What’s next</a></li>
</ul>

<h2 id="管理技巧">管理技巧</h2>

<p><strong>警告:</strong> Kubernetes 对象应该只使用一种技术进行管理。混合使用不同的技术，会导致相同对象出现未定义的行为。</p>

<table>
  <thead>
    <tr>
      <th>管理技术</th>
      <th>操作</th>
      <th>推荐环境</th>
      <th>支持撰写</th>
      <th>学习曲线</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>命令式的方式</td>
      <td>活动对象</td>
      <td>开发项目</td>
      <td>1+</td>
      <td>最低</td>
    </tr>
    <tr>
      <td>命令式对象配置</td>
      <td>单文件</td>
      <td>生产项目</td>
      <td>1</td>
      <td>中等</td>
    </tr>
    <tr>
      <td>声明式对象配置</td>
      <td>文件目录</td>
      <td>生产项目</td>
      <td>1+</td>
      <td>最高</td>
    </tr>
  </tbody>
</table>

<h2 id="命令式的方式">命令式的方式</h2>

<p>当使用命令式的命令时，用户直接对集群中的活动对象进行操作。用户提供 <code class="highlighter-rouge">kubectl</code> 命令的参数或标记进行操作。</p>

<p>这是在集群中启动或运行一次性任务的最简单的方法。因为这种技术直接在活动对象上运行，所以它没有提供以前配置的历史记录。</p>

<h3 id="例子">例子</h3>

<p>通过创建 Deployment 对象来运行 nginx 容器的实例:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl run nginx <span class="nt">--image</span> nginx
</code></pre></div></div>

<p>使用不同的语法做同样的事情:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl create deployment nginx <span class="nt">--image</span> nginx
</code></pre></div></div>

<h3 id="权衡">权衡</h3>

<p>与对象配置相比的优点:</p>

<ul>
  <li>命令简单易学，易于记忆。</li>
  <li>命令只需要一个步骤即可对群集进行更改。</li>
</ul>

<p>与对象配置相比的缺点:</p>

<ul>
  <li>命令不与变更审核流程整合。</li>
  <li>命令不提供与更改相关联的审计跟踪。</li>
  <li>除了活动对象之外，命令不提供记录来源。</li>
  <li>命令不提供用于创建新对象的模板。</li>
</ul>

<h2 id="命令式对象配置">命令式对象配置</h2>

<p>在命令式对象配置中，<code class="highlighter-rouge">kubectl</code> 命令指定操作(创建，替换等)，可选标志和至少一个文件名称。指定的文件必须包含对象的完整定义以 YAML 或 JSON 格式。</p>

<p>请参阅<a href="https://kubernetes.io/docs/resources-reference/v1.6/">参考资源</a>
查看有关对象定义的更多细节。</p>

<p><strong>警告:</strong> 命令式 <code class="highlighter-rouge">replace</code> 命令用新提供的命令替换现有资源规格，将对配置文件中缺少的对象的所有更改都丢弃。这种方法不应更新与配置文件无关的资源类型。例如，<code class="highlighter-rouge">LoadBalancer</code> 类型的服务使其 <code class="highlighter-rouge">externalIPs</code> 字段与集群的配置无关。</p>

<h3 id="例子-1">例子</h3>

<p>创建对象定义配置文件:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl create <span class="nt">-f</span> nginx.yaml
</code></pre></div></div>

<p>删除两个配置文件中定义的对象:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl delete <span class="nt">-f</span> nginx.yaml <span class="nt">-f</span> redis.yaml
</code></pre></div></div>

<p>通过覆写实时配置更新配置文件中定义的对象:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl replace <span class="nt">-f</span> nginx.yaml
</code></pre></div></div>

<h3 id="权衡-1">权衡</h3>

<p>与命令式的命令相比的优点:</p>

<ul>
  <li>对象配置可以存储在源码控制系统中，如Git。</li>
  <li>对象配置可以与进程集成，例如在推送和审计跟踪之前查看更改。</li>
  <li>对象配置提供了一个用于创建新对象的模板。</li>
</ul>

<p>与命令式的命令相比的缺点:</p>

<ul>
  <li>对象配置需要对对象模式有基本的了解。</li>
  <li>对象配置需要编写 YAML 文件的附加步骤。</li>
</ul>

<p>与声明式对象配置相比的优势:</p>

<ul>
  <li>命令对象配置行为更简单易懂。</li>
  <li>至于 Kubernetes 1.5 版本，命令式对象配置更为成熟。</li>
</ul>

<p>与声明式对象配置相比的缺点:</p>

<ul>
  <li>命令对象配置最适合于文件，而不是目录。</li>
  <li>活动对象的更新必须反映在配置文件中，否则在下次更替时将丢失。</li>
</ul>

<h2 id="声明式对象配置">声明式对象配置</h2>

<p>当使用声明式对象配置时，用户对本地存储的对象配置文件进行操作，但是用户没有定义要对文件执行的操作。通过 <code class="highlighter-rouge">kubectl</code> 自动检测每个对象进行创建、更新和删除操作。这样可以在目录层级上工作，因为不同的对象可能需要不同的操作。</p>

<p><strong>注意:</strong> 声明式对象配置保留由其他对象进行的更改，即使更改未合并到对象配置文件中。这可以通过使用 <code class="highlighter-rouge">patch</code> API 操作来写入观察到的差异，而不是使用<code class="highlighter-rouge">replace</code> API 操作来替换整个对象的配置。</p>

<h3 id="例子-2">例子</h3>

<p>处理<code class="highlighter-rouge">configs</code> 目录中的所有对象配置文件，创建或修补(patch)活动对象:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="nt">-f</span> configs/
</code></pre></div></div>

<p>递归处理目录:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="nt">-R</span> <span class="nt">-f</span> configs/
</code></pre></div></div>

<h3 id="权衡-2">权衡</h3>

<p>与命令式对象配置相比的优点:</p>

<ul>
  <li>直接对活动对象进行的更改将被保留，即使它们未被并入到配置文件中。</li>
  <li>声明式对象配置更好地支持目录操作，并自动检测每个对象的操作类型 (创建、修补，删除)。</li>
</ul>

<p>与命令式对象配置相比的缺点:</p>

<ul>
  <li>声明式对象配置在意外情况下难以调试和了解结果。</li>
  <li>使用差异的部分更新会创建复杂的合并和补丁操作。</li>
</ul>

<h2 id="whats-next">What’s next</h2>

<ul>
  <li><a href="/docs/tutorials/object-management-kubectl/imperative-object-management-command/">使用命令式的命令管理 Kubernetes 对象</a></li>
  <li><a href="/docs/tutorials/object-management-kubectl/imperative-object-management-configuration/">使用对象配置管理 Kubernetes 对象(必要)</a></li>
  <li><a href="/docs/tutorials/object-management-kubectl/declarative-object-management-configuration/">使用对象配置(声明式)管理 Kubernetes 对象</a></li>
  <li><a href="/docs/user-guide/kubectl/v1.6/">Kubectl 命令参考</a></li>
  <li><a href="/docs/resources-reference/v1.6/">Kubernetes 对象模式参考</a></li>
</ul>

